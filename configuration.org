#+TITLE: My wonderful Emacs configuration
#+AUTHOR: LeReverandNox

* Use sensible-defaults.el
  Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] by [[https://github.com/hrs/sensible-defaults.el][@HRS]] to setup basic and usefull stuff without
  recoding it myself :)

  #+BEGIN_SRC emacs-lisp
    (load (concat user-emacs-directory "config/sensible-defaults/sensible-defaults.el"))

    (sensible-defaults/shorten-yes-or-no)
    (sensible-defaults/delete-trailing-whitespace)
    (sensible-defaults/show-matching-parens)
    (sensible-defaults/make-scripts-executable)
    (sensible-defaults/overwrite-selected-text)
    (sensible-defaults/ensure-that-files-end-with-newline)
    (sensible-defaults/confirm-closing-emacs)
    (sensible-defaults/quiet-startup)
    (sensible-defaults/always-highlight-code)
    (sensible-defaults/refresh-buffers-when-files-change)
    (sensible-defaults/bind-commenting-and-uncommenting)
    (sensible-defaults/set-default-line-length-to 80)
    (sensible-defaults/flash-screen-instead-of-ringing-bell)
  #+END_SRC

* Package management (=package=, =use-package= and =auto-compile=)
** Setup =package= and it' s sources...
*** Setup
    Note to myself: I need to try [[https://emacs.stackexchange.com/a/2989][that]] sometime, to achieve source
    prioritization. For now, let's disable =melpa-stable=
    #+BEGIN_SRC emacs-lisp
      (require 'package)
      (setq package-enable-at-startup nil)

      (unless (assoc-default "org" package-archives)
        (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/")))
      (unless (assoc-default "melpa" package-archives)
        (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/")))
      ;; (unless (assoc-default "melpa-stable" package-archives)
      ;; (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/")))

      (when (< emacs-major-version 27)
        (package-initialize))
    #+END_SRC

    Don't forget to run =M-x package-refresh-contents= to reload the package list
    when you add a new source or if you can't find a package.

*** Upgrade
    From [[https://emacs.stackexchange.com/a/31874][this]] post.

    To upgrade packages, run =M-x list-packages=, hit =U= (=package-menu-mark-upgrades=) to mark available
    upgrades, then =x= (=package-menu-execute=) to install them and finally =y= to confirm.
    Then run =M-x package-autoremove= to remove old versions.\\
    Apparently, it can be done via another package... but for now I prefer to do
    it manually.

    Here's 2 cool functions from the StackExchange post, to save some time in
    the package menu.\\
    The first one allows to find marked packages and the second one allows to
    filter by status. Respectively bind to =a= and =s=

    #+BEGIN_SRC emacs-lisp
      (defun package-menu-find-marks ()
        "Find packages marked for action in *Packages*."
        (interactive)
        (occur "^[A-Z]"))

      ;; Only in Emacs 25.1+
      (defun package-menu-filter-by-status (status)
        "Filter the *Packages* buffer by status."
        (interactive
         (list (completing-read
                "Status: " '("available" "new" "installed" "dependency" "obsolete"))))
        (package-menu-filter (concat "status:" status)))

      (with-eval-after-load 'evil
        (evil-define-key 'normal package-menu-mode-map (kbd "s") 'package-menu-filter-by-status)
        (evil-define-key 'normal package-menu-mode-map (kbd "a") 'package-menu-find-marks))
    #+END_SRC

** then, setup =use-package=, our beloved package-manager...
   See [[https://github.com/jwiegley/use-package][here]].
   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))
   #+END_SRC

   Always ensure packages are installed, to avoid repetition

   #+BEGIN_SRC emacs-lisp
     (setq use-package-always-ensure t)
   #+END_SRC

   Require additional modules to use cool features of =use-package=

   #+BEGIN_SRC emacs-lisp
     (require 'diminish)  ;; if you use :diminish
     (require 'bind-key)  ;; if you use any :bind variant
   #+END_SRC

** and finally, use =auto-compile= to always compile packages and use the latest version.
   #+BEGIN_SRC emacs-lisp
     (use-package auto-compile
       :init
       ;; Prevent outdated byte-code loading
       (setq load-prefer-newer t)
       :config
       (progn
         ;; Auto-compile before loading if byte-code is outdated
         (auto-compile-on-load-mode)))
   #+END_SRC
* Custom map
  After some research, I found [[https://karl-voit.at/2018/07/08/emacs-key-bindings/][this]] interesting article about how to deal with
  custom keybindings in order to avoid messing with the default Emacs and
  package bindings.

  Idealy, I wish I could have used only =hydra= to achieve this, but for now,
  you can't add heads to an exhisting =hydra=, you need to declare all at
  once, in a same spot...\\
  I can't do that, I want to keep my config 'orgagnized' by logical section, each one
  having it's own set of related bindings.

  So I decided to create my personal map here, and then, add as many =hydra= I
  need in it.

  I also didn't knew what keybinding to choose for my map. After a bit of
  research ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html][this]] ressource was really helpful) and some trial and error, =C-c c=
  seems like a decent choice.
  It didn't seems to be used (for now) by any of the packages that I use.


  #+BEGIN_SRC emacs-lisp
    (bind-keys :prefix "C-c c"
               :prefix-map lrn/custom-map
               :prefix-docstring "My very own custom map to hold a lotta stuff")
  #+END_SRC

* 42 Headers
  Use the official 42 headers in C/CPP files.

  #+BEGIN_SRC emacs-lisp
    (load (concat user-emacs-directory "config/42/list.el"))
    (load (concat user-emacs-directory "config/42/string.el"))
    (load (concat user-emacs-directory "config/42/comments.el"))
    (load (concat user-emacs-directory "config/42/header.el"))

    (bind-key "h" 'header-insert lrn/custom-map)
  #+END_SRC

* =Evil=
  I love Emacs, but I can't live without Vim bindings...
  Ever since I watched [[https://www.youtube.com/watch?v=JWD1Fpdd4Pc][this]] video, I knew it was only a matter of time until I
  switch to Emacs

  So without further ado, ladies and gentlemen : EVIL !
  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :bind (
             :map evil-normal-state-map
             ;; I need to unbind M-. to make goto-definition work when programming
             ("M-." . nil)
             :map evil-motion-state-map
             ;; Also need to unbind C-i (evil-jump-forward) for hideshow-org to works
             ;; Since the keycode for TAB and C-i is the same, and I don't want to find a workaround for now...
             ("C-i" . nil)
             ;; Rebind (evil-jump-forward) to C-S-o
             ("C-S-o" . evil-jump-forward))
      :init
      (progn
        ;; Don't expand the abbrev when going back to Normal state
        (setq evil-want-abbrev-expand-on-insert-exit nil)
        ;; Shift lines by 2 spaces
        (setq-default evil-shift-width 2)
        ;; Enable Evil bindings in the minibuffer
        (setq evil-want-minibuffer t)
        ;; Don't use regex during search
        (setq evil-regexp-search nil)
        ;; Use much more smaller step for undo
        (setq evil-want-fine-undo t)
        ;; Disable keybindings, for evil-collection
        (setq evil-want-keybinding nil))
      :config
      (progn
        (evil-mode t)))
  #+END_SRC

  =evil-collection= adds a shitload of keybindings for a shitload of modes.
  I don't know if it worth it, but I'm gonna give it a shot.
  #+BEGIN_SRC emacs-lisp
    (use-package evil-collection
      :after evil
      :config
      (progn
        ;; Disable neotree bindings, I'm already happy with mine
        (setq evil-collection-mode-list (remove 'neotree evil-collection-mode-list))
        ;; Disable outline bindings, conflict with TAB (org-cycle)
        (setq evil-collection-mode-list (remove 'outline evil-collection-mode-list))
        (evil-collection-init)))
  #+END_SRC

  Let's also add =evil-surround= and =evil-mc=, to have surrounding and
  multi-cursors, just like Vim ! Hu-uh !
  #+BEGIN_SRC emacs-lisp
    (use-package evil-surround
      :config
      (global-evil-surround-mode t))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package evil-mc
      :diminish evil-mc-mode
      :config
      (global-evil-mc-mode 1))
  #+END_SRC

  Let's make an =hydra= to bind =evil-mc= commands on my custom map
  #+BEGIN_SRC emacs-lisp
    (defhydra lrn/hydra-evil-mc (
                                 :color pink
                                 :hint nil)
      "
              ^Up^                        ^Down^                     ^Other^
    -----------------------------------------------------------------------------------
    [_k_]   Make & prev line    [_j_]   Make & next line    [_<mouse-1>_] Make at click
    [_p_]   Make & prev match   [_n_]   Make & next match   [_a_]         Make all
    [_C-p_] Make & prev curs.   [_C-n_] Make & netxt curs.  [_u_]         Undo all
    [_P_]   Skip & prev match   [_N_]   Skip & next match   [_q_]         Quit
    [_C-P_] Skip & prev curs.   [_C-N_] Skip & prev curs.
    "
      ("k" evil-mc-make-cursor-move-prev-line)
      ("p" evil-mc-make-and-goto-prev-match)
      ("C-p" evil-mc-make-and-goto-prev-cursor)
      ("P" evil-mc-skip-and-goto-prev-match)
      ("C-P" evil-mc-skip-and-goto-prev-cursor)
      ("j" evil-mc-make-cursor-move-next-line)
      ("n" evil-mc-make-and-goto-next-match)
      ("C-n" evil-mc-make-and-goto-next-cursor)
      ("N" evil-mc-skip-and-goto-next-match)
      ("C-N" evil-mc-skip-and-goto-next-cursor)
      ("<mouse-1>" evil-mc-toggle-cursor-on-click)
      ("a" evil-mc-make-all-cursors :color blue)
      ("u" evil-mc-undo-all-cursors :color blue)
      ("<down-mouse-1>" ignore :hint nil)
      ("<drag-mouse-1>" ignore :hint nil)
      ("q" nil)
      ("C-g" nil))
    (bind-key "m" 'lrn/hydra-evil-mc/body lrn/custom-map)
  #+END_SRC
* UI / UX
** Tweak UI
   Hide menu / tool / scroll bars, for I don't use them
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC

   Always show line-numbers in margin. Can't live without it !
   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode t)
   #+END_SRC

   Make the frame title a bit more meaningful by displaying the current project
   name instead of the current filename
   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format '((:eval (projectile-project-name))))
   #+END_SRC
** Theme
   Set the =themes= directory
   #+BEGIN_SRC emacs-lisp
     (setq custom-theme-directory
           (concat user-emacs-directory "themes"))
   #+END_SRC

   +Load my (current) favorite theme, earthsong+
   #+BEGIN_SRC emacs-lisp
     ;; (load-theme 'earthsong t)
   #+END_SRC

   Okay, let's try one of my other favorite theme, One Dark from Atom.
   #+BEGIN_SRC emacs-lisp
     (use-package atom-one-dark-theme
       :config
       (progn
         (load-theme 'atom-one-dark t)))
   #+END_SRC

   I love some transparency. Let's make it a bit transparent when active, and a
   bit more transparent when inactive
   #+BEGIN_SRC emacs-lisp
     ;;(set-frame-parameter (selected-frame) 'alpha '(<active> . <inactive>))
     (set-frame-parameter (selected-frame) 'alpha '(95 . 80))
     (add-to-list 'default-frame-alist '(alpha . (95 . 80)))
   #+END_SRC

   I also like to have a more visible =verbatim= face in =org-mode=.
   Not quite sur about the color, but it will do the trick.
   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'org-verbatim nil
                         :foreground (face-attribute 'warning :foreground))
   #+END_SRC

** Font
   Thanks again to @HRS for those really helpful functions !

*** Setup
    Let's set =RobotoMono Nerd Font= as the default font
    #+BEGIN_SRC emacs-lisp
      (setq hrs/default-font "RobotoMono Nerd Font")
    #+END_SRC

    With a default size of 11
    #+BEGIN_SRC emacs-lisp
      (setq hrs/default-font-size 11)
    #+END_SRC

*** Resizing
    Really cool fonctions :)
    #+BEGIN_SRC emacs-lisp
      (defun hrs/font-code ()
        "Return a string representing the current font (like \"Inconsolata-14\")."
        (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

      (defun hrs/set-font-size ()
        "Set the font to `hrs/default-font' at `hrs/current-font-size'.
         Set that for the current frame, and also make it the default for
         other, future frames."
        (let ((font-code (hrs/font-code)))
          (add-to-list 'default-frame-alist (cons 'font font-code))
          (set-frame-font font-code)))

      (defun hrs/reset-font-size ()
        "Change font size back to `hrs/default-font-size'."
        (interactive)
        (setq hrs/current-font-size hrs/default-font-size)
        (hrs/set-font-size))

      (defun hrs/increase-font-size ()
        "Increase current font size by a factor of `hrs/font-change-increment'."
        (interactive)
        (setq hrs/current-font-size
              (ceiling (* hrs/current-font-size hrs/font-change-increment)))
        (hrs/set-font-size))

      (defun hrs/decrease-font-size ()
        "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
        (interactive)
        (setq hrs/current-font-size
              (max 1
                   (floor (/ hrs/current-font-size hrs/font-change-increment))))
        (hrs/set-font-size))
    #+END_SRC

    Increment font by 0.5%
    #+BEGIN_SRC emacs-lisp
      (setq hrs/font-change-increment 1.05)
    #+END_SRC

    Let's create an =hydra= to resize the font and bind it on my custom map.
    #+BEGIN_SRC emacs-lisp
      (defhydra lrn/hydra-font-size ()
        "Resize the font"
        ("=" hrs/increase-font-size "bigger")
        ("-" hrs/decrease-font-size "smaller")
        ("0" hrs/reset-font-size "reset")
        ("q" nil "quit"))
      (bind-key "=" 'lrn/hydra-font-size/body lrn/custom-map)
    #+END_SRC

    Reset the font size at startup
    #+BEGIN_SRC emacs-lisp
      (hrs/reset-font-size)
    #+END_SRC
** Modeline
*** =powerline=
    I love Vim's powerline, so when I heard there's an Emacs version...

    Here's a fork of the =powerline-evil-center-color-theme= (from [[https://github.com/raugturi/powerline-evil][here]]) that
    display the =mode-line-misc-info= variable. I need it for =eyebrowse= to
    display it's workspaces. (see [[https://github.com/milkypostman/powerline/issues/140][this]] issue)\\
    I don't really know what I'm doing, I just tried to
    understand roughly how a =mode-line-format= works and hacked my way through.
    #+BEGIN_SRC emacs-lisp
      (defun lrn/powerline-evil-center-color-theme ()
        "A custom Powerline's center-evil them with the evil state in color and the
        mode-line-misc-info displayed."
        (interactive)
        (setq-default mode-line-format
                      '("%e"
                        (:eval
                         (let* ((active (powerline-selected-window-active))
                                (mode-line (if active 'mode-line 'mode-line-inactive))
                                (face1 (if active 'powerline-active1 'powerline-inactive1))
                                (face2 (if active 'powerline-active2 'powerline-inactive2))
                                (separator-left (intern (format "powerline-%s-%s"
                                                                (powerline-current-separator)
                                                                (car powerline-default-separator-dir))))
                                (separator-right (intern (format "powerline-%s-%s"
                                                                 (powerline-current-separator)
                                                                 (cdr powerline-default-separator-dir))))
                                (lhs (list (powerline-raw "%*" nil 'l)
                                           (powerline-buffer-size nil 'l)
                                           (powerline-buffer-id nil 'l)
                                           (powerline-raw " ")
                                           (funcall separator-left mode-line face1)
                                           (powerline-narrow face1 'l)
                                           (powerline-vc face1)))
                                (rhs (list (powerline-raw global-mode-string face1 'r)
                                           (powerline-raw "%4l" face1 'r)
                                           (powerline-raw ":" face1)
                                           (powerline-raw "%3c" face1 'r)
                                           (funcall separator-right face1 mode-line)
                                           (powerline-raw " ")
                                           (powerline-raw "%6p" nil 'r)
                                           (powerline-hud face2 face1)
                                           (powerline-raw mode-line-misc-info face2 'r)))
                                (center (append (list (powerline-raw " " face1)
                                                      (funcall separator-left face1 face2)
                                                      (when (boundp 'erc-modified-channels-object)
                                                        (powerline-raw erc-modified-channels-object face2 'l))
                                                      (powerline-major-mode face2 'l)
                                                      (powerline-process face2)
                                                      (powerline-raw " " face2))
                                                (let ((evil-face (powerline-evil-face)))
                                                  (if (split-string (format-mode-line minor-mode-alist))
                                                      (append (if evil-mode
                                                                  (list (funcall separator-right face2 evil-face)
                                                                        (powerline-raw (powerline-evil-tag) evil-face 'l)
                                                                        (powerline-raw " " evil-face)
                                                                        (funcall separator-left evil-face face2)))
                                                              (list (powerline-minor-modes face2 'l)
                                                                    (powerline-raw " " face2)
                                                                    (funcall separator-right face2 face1)))
                                                    (list (powerline-raw (powerline-evil-tag) evil-face)
                                                          (funcall separator-right evil-face face1)))))))
                           (concat (powerline-render lhs)
                                   (powerline-fill-center face1 (/ (powerline-width center) 2.0))
                                   (powerline-render center)
                                   (powerline-fill face1 (powerline-width rhs))
                                   (powerline-render rhs)))))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package powerline
        :config
        (lrn/powerline-evil-center-color-theme))
    #+END_SRC
*** Clock
    It's sometime more convenient to check the time directly in Emacs, instead of
    looking at the OS status bar. Especially in fullscreen mode.\\
    I not enabling it for now, for I spend most of my time on MacOS. But I use it
    for sure on Linux.

    #+BEGIN_SRC emacs-lisp
      ;; (display-time-mode)

    #+END_SRC

    Let's also customize the time format. See [[https://help.gnome.org/users/gthumb/stable/gthumb-date-formats.html.en][here]] for reference :)
    #+BEGIN_SRC emacs-lisp
      (setq display-time-format "%H:%M:%S")
    #+END_SRC
*** =diminish=
    The =modeline= is often waaaay to crowded, when a lot of modes are enabled.
    Hopefully, there's =dimisish= ! It allows you to rename every minor/major
    modes to save space.

    =diminish= is also supported directly by =use-package= with the =:dimish= option.
    I try to use it whenever I can, but for some default modes, I still need to
    write it here.

    First, two macros to make things easier
    #+BEGIN_SRC emacs-lisp
      (defmacro diminish-minor-mode (filename mode &optional abbrev)
        `(eval-after-load (symbol-name ,filename)
           '(diminish ,mode ,abbrev)))

      (defmacro diminish-major-mode (mode-hook abbrev)
        `(add-hook ,mode-hook
                   (lambda () (setq mode-name ,abbrev))))
    #+END_SRC

    And now =diminish=  itself.
    #+BEGIN_SRC emacs-lisp
      (use-package diminish
        :config
        (diminish-major-mode 'emacs-lisp-mode-hook "el")
        (diminish-major-mode 'python-mode-hook "Py")
        (diminish-major-mode 'js-mode-hook "JS")
        (diminish-major-mode 'sh-mode-hook "Sh")
        (diminish-minor-mode 'abbrev 'abbrev-mode))
    #+END_SRC
** Icons
   Because it's always nice to have cool icons instead of plain text
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons)
   #+END_SRC
** =neotree=
   Similar to Vim's Nerdtree, such a cool package to browse the filesystem in a
   conveniant sidebar <3

   Thanks [[https://github.com/jaypei/emacs-neotree/issues/293][@stereoproxy]] for this function that allows me to close the parent
   directory of a node easily !
   #+BEGIN_SRC emacs-lisp
     (defun my/neotree-close-parent ()
       "Close parent directory of current node."
       (interactive)
       (neotree-select-up-node)
       (let* ((btn-full-path (neo-buffer--get-filename-current-line))
              (path (if btn-full-path btn-full-path neo-buffer--start-node)))
         (when (file-name-directory path)
           (if (neo-buffer--expanded-node-p path) (neotree-enter)))))
   #+END_SRC

   Thanks to [[https://emacs.stackexchange.com/a/29500][@ideasman42]] for this function that will open =neotree= at the
   current =projectile= root, or the directory of the current buffer if not in a
   projet. I'll use it instead of =neotree-projectile-action=.
   #+BEGIN_SRC emacs-lisp
     (defun my/neotree-project-dir-toggle ()
       "Open NeoTree using the project root, using find-file-in-project,
     or the current buffer directory."
       (interactive)
       (let ((project-dir
              (ignore-errors
                ;;; Pick one: projectile or find-file-in-project
                ; (projectile-project-root)
                (ffip-project-root)
                ))
             (file-name (buffer-file-name))
             (neo-smart-open t))
         (if (and (fboundp 'neo-global--window-exists-p)
                  (neo-global--window-exists-p))
             (neotree-hide)
           (progn
             (neotree-show)
             (if project-dir
                 (neotree-dir project-dir))
             (if file-name
                 (neotree-find file-name))))))
   #+END_SRC

   Let's install =neotree= and set the bindings
   #+BEGIN_SRC emacs-lisp
          (use-package neotree
            :bind (
                   :map neotree-mode-map
                   ;; Neotree doesn't respect the binding convention, it conflicts with my custom map.
                   ("C-c c" . nil)
                   ("s" . neotree-enter-horizontal-split)
                   ("v" . neotree-enter-vertical-split)
                   ("y" . neotree-copy-filepath-to-yank-ring)
                   ("r" . neotree-refresh)
                   ("C-c C-y" . neotree-copy-node)
                   ("x" . my/neotree-close-parent)
                   ("<tab>" . neotree-change-root)
                   ("j" . neotree-next-line)
                   ("k" . neotree-previous-line))
            :init
            (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
            (setq neo-window-fixed-size nil)
            ;; Switch to Emacs state when entering neotree-mode, no need for Evil there.
            (evil-set-initial-state 'neotree-mode 'emacs)
            (bind-key "n" 'neotree-show lrn/custom-map)
            (bind-key "N" 'my/neotree-project-dir-toggle lrn/custom-map))
   #+END_SRC

** Completion
*** =helm= and friends
    From [[https://github.com/emacs-helm/helm][here]].\\
    See [[https://emacs-helm.github.io/helm/][here]] and [[http://tuhdo.github.io/helm-intro.html][here]].

    =helm= is just AWESOME ! It saves so much time, allowing to find anything in
    a few keystrokes.

    First, there is =helm= itself
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm
      ;;   :diminish helm-mode
      ;;   :bind  (
      ;;          ("M-x" . helm-M-x)
      ;;          ("C-x C-f" . helm-find-files)
      ;;          ("C-x y" . helm-show-kill-ring)
      ;;          ("C-x b" . helm-mini)
      ;;          ("C-X c o" . helm-occur)
      ;;          ("C-h a" . helm-apropos))
      ;;   :init
      ;;   (setq projectile-completion-system 'helm)
      ;;   (setq helm-apropos-fuzzy-match t)
      ;;   :config
      ;;   (helm-mode t))
    #+END_SRC

    then, there's =helm-descbinds=, for searching bindings
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm-descbinds
      ;;   :bind (
      ;;          ("C-h b" . helm-descbinds)
      ;;          ("C-h w" . helm-descbinds)))
    #+END_SRC

*** =ivy= and friends
    Ressources: [[https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/][that]], [[https://adamsimpson.net/writing/helm-to-ivy][this]], [[http://blog.binchen.org/posts/hello-ivy-mode-bye-helm.html][that]], [[https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html][this]].

**** =ivy=
     From [[https://github.com/abo-abo/swiper][here]]. See [[https://oremacs.com/swiper/][here]].\\
     The completion framework itself. Waaay way smaller than =helm=, with less
     functionalities. But since I was using about 5% of =helm=, it doesn't matter

     =ivy-historian= persists the =ivy= candidates in a file.
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-historian)
     #+END_SRC

     =ivy-hydra= transforms =ivy-dispatching-done= into
     =ivy-dispatching-done-hdyra= and adds an =hydra= to =ivy= minibuffers.\\
     (It's suppose to be bound on =C-o=, but this binding his conflicting with
     =evil-jump-backward=, so instead I chose =C-M-o=)
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-hydra)
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (use-package ivy
         :diminish ivy-mode
         :bind (
                ("C-x b" . ivy-switch-buffer)
                :map ivy-minibuffer-map
                ("C-M-o" . hydra-ivy/body)
                )
         :init
         ;; Add recent files and bookmarks to ivy-switch-buffer
         (setq ivy-use-virtual-buffers t)
         ;; Show the fullpath for the recent files in ivy-switch-buffer
         (setq ivy-virtual-abbreviate 'fullpath)
         ;; Use ivy as completion system for projectile
         (setq projectile-completion-system 'ivy)
         ;; Require to type ~/ to go home, instead of just ~
         (setq ivy-magic-tilde nil)
         ;; Allow minibuffer commands in minibuffer... MINIBUFFERCEPTION \o/
         (setq enable-recursive-minibuffers t)
         :config
         (ivy-historian-mode t)
         (ivy-mode t))
     #+END_SRC
**** =counsel=
     =counsel= is a collection of replacement functions for various Emacs
     commands, infused with =ivy=.

     #+BEGIN_SRC emacs-lisp
       (use-package counsel
         :diminish counsel-mode
         :bind (
                ("C-x y" . counsel-yank-pop))
         :init
         ;; Override the binding descriptions with counsel stuff
         (setq counsel-mode-override-describe-bindings t)
         :config
         (counsel-mode t))
     #+END_SRC

** Keybindings help
*** =guide-key=
    From [[https://github.com/kai2nenobu/guide-key][here]].

    =guide-key= is a cool little package that shows a popup with the possibles
    key-bindings when you start typing. Really useful to discover a lot of cool
    bindings !
    #+BEGIN_SRC emacs-lisp
      ;; (use-package guide-key
      ;;   :diminish guide-key-mode
      ;;   :init
      ;;   (setq guide-key/guide-key-sequence t) ; Trigger the guide for any binding
      ;;   (setq guide-key/popup-window-position 'bottom)
      ;;   (setq guide-key/align-command-by-space-flag t)
      ;;   (setq guide-key/idle-delay 0.75)
      ;;   :config
      ;;   (progn
      ;;     (guide-key-mode 1)))
    #+END_SRC
*** =which-key=
    From [[https://github.com/justbur/emacs-which-key][here]].

    Based on =guide-key=, it was developped for [[https://www.google.com/search?client=firefox-b-ab&q=github+spcemacs][Spacemacs]]. It does the same
    things, but... in a cooler way. Maybe.

    Let's give it a shot and see what it worth.
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :diminish which-key-mode
        :init
        (setq which-key-popup-type 'side-window)
        (setq which-key-idle-delay 0.75)
        :config
        (which-key-mode t))
    #+END_SRC

*** =free-keys=
    From [[https://github.com/Fuco1/free-keys][here]].\\
    This cool package shows the free bindings available for the current buffer.

    Used with =describe-personal-bindings= (from =bind-key=), it helps a lot to
    define bindings that will not conflict with existing ones.
    #+BEGIN_SRC emacs-lisp
      (use-package free-keys
        :init
        (setq free-keys-modifiers '("" "C" "M" "C-M" "M-S")))
    #+END_SRC
** Sessions
   Emacs can save and restore the current session. Convenient since I'm closing
   Emacs often !

   Themes settings are also stored in the .desktop file... So if I change
   settings with =customize-face= then exit Emacs, those settings are restored
   the next time ! I don't like this behavior. Thanks to [[https://superuser.com/a/1155381][this]] post, there's a
   worakoung that reloads the actual theme after restoring the .desktop

   EDIT: Since I start using =--daemon= / =emacsclient=, I had to fix
   =desktop-save=mode= so I can restore frames in a new frame... But it seems to
   have broken the up-mentioned workaround...  will (try) to-fix someday.
   #+BEGIN_SRC emacs-lisp
     (setq desktop-path (list (concat user-emacs-directory "tmp/sessions")))
     (desktop-save-mode)
     (setq desktop-restore-forces-onscreen nil)
     (setq desktop-load-locked-desktop t)

     ;; (add-to-list 'desktop-globals-to-save 'custom-enabled-themes)
     ;; (defun desktop-load-theme () "load custom theme" (interactive)
     ;; (dolist (th custom-enabled-themes) (load-theme th)))
     ;; (add-hook 'desktop-after-read-hook 'desktop-load-theme)
   #+END_SRC

** Custom-file
   Emacs use a custom-file to store settings set by =M-x customize= and other
   stuff.

   Let's configure it.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "config/custom.el"))
   #+END_SRC

   And load it at startup.
   #+BEGIN_SRC emacs-lisp
     (load custom-file)
   #+END_SRC
** =Dired=
   I want to use =dired-mode= more often, it seems really powerful !
   Let's customize some settings

   =dired-dwim-target= allows to 'auto-detect' the target for various operations
   such as copy, delete, etc... (If there's a split window with a =Dired=
   buffer, it'll assume that you want to target this directory)
   #+BEGIN_SRC emacs-lisp
     (setq dired-dwim-target t)
   #+END_SRC

   Always copy directory recursively without confirmation
   #+BEGIN_SRC emacs-lisp
     (setq dired-recursive-copies 'always)
   #+END_SRC

   The basic =ls= flags are quite limited (=-al=), let's add s'more, such as
   human-readable sizes
   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-lah")
   #+END_SRC

   Auto-update the =dired= buffers if the content of a directory change.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook 'auto-revert-mode)
   #+END_SRC

   You now you can edit permissions directly from within =dired= ?
   #+BEGIN_SRC emacs-lisp
     (setq wdired-allow-to-change-permissions t)
   #+END_SRC

*** =dired+=
    =dired+= is a package that provides additional features to the basic
    =dired-mode=
    However, I had to intall it manually, since it's not present on
    =MELPA= anymore ='(
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'load-path (concat user-emacs-directory "config/dired-plus"))
      (require 'dired+)
    #+END_SRC

*** =dired-narrow=
    A cool package that allows to filter files by name ! (See [[http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/][here]])

    In a =dired= buffer, hit =C-s= to invok =dired-narrow= and type a string to
    filter.\\
    When done, hit =g r= (=revert-buffer=) to remove the filters.
    #+BEGIN_SRC emacs-lisp
      (use-package dired-narrow
        :config
        (progn
          (evil-define-key 'normal dired-mode-map (kbd "C-s") 'dired-narrow)))
    #+END_SRC

*** =dired-quick-sort=
    See [[https://gitlab.com/xuhdev/dired-quick-sort][here]].
    Add a cool sorting menu to =dired=, to sort by name, time, size, extension,
    you name it...

    WARNING: Doesn't work on Mac OS, since =ls= doesn't support =--dired= option.
    #+BEGIN_SRC emacs-lisp
      (unless (string-equal system-type "darwin")
        (use-package dired-quick-sort
          :config
          (dired-quick-sort-setup))
        )
    #+END_SRC
** Emacs server
   Let's add a binding to kill the Emacs server.
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "C-x C-S-c") 'kill-emacs)
   #+END_SRC
* Persitency
** =backup= and =auto-save=
   I love to keep my backups and auto-saves neatly in separates directories.
   This is the first settings I used when I start using Emacs in 2016, I should
   review them someday.
   #+BEGIN_SRC emacs-lisp
     (let ((backup-dir (concat user-emacs-directory "tmp/backups"))
           (auto-saves-dir (concat user-emacs-directory "tmp/auto-saves")))
       (dolist (dir (list backup-dir auto-saves-dir))
         (when (not (file-directory-p dir))
           (make-directory dir t)))
       (setq backup-directory-alist `(("." . ,backup-dir))
             auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
             auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
             tramp-backup-directory-alist `((".*" . ,backup-dir))
             tramp-auto-save-directory auto-saves-dir))

     (setq backup-by-copying t    ; Don't delink hardlinks
           delete-old-versions t  ; Clean up the backups
           version-control t      ; Use version numbers on backups,
           kept-new-versions 5    ; keep some new versions
           kept-old-versions 2)   ; and some old ones, too
   #+END_SRC

** History
   From [[http://pages.sachachua.com/.emacs.d/Sacha.html#org40a3abb][here]] (and from [[https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html][here]] too)
   It's cool to be able to re-run commands, searches and stuff from a previous session
   when opening Emacs.

   #+BEGIN_SRC emacs-lisp
     (setq savehist-file (concat user-emacs-directory "tmp/savehist"))
     (savehist-mode +1)
     (setq savehist-save-minibuffer-history +1)
     (setq savehist-additional-variables
           '(kill-ring
             search-ring
             regexp-search-ring))
   #+END_SRC

** =save-place=
   =save-place-mode= saves the current point location when I close a
   file or Emacs.
   So when I come back, the point position is restored !
   #+BEGIN_SRC emacs-lisp
     (save-place-mode t)
   #+END_SRC

* Editing
  Some settings I didn't know where to put... not really Programming stuff, but
  kinda' quand meme.

** Encoding
   Set default encoding to UTF-8, because it's most common. And the coolest !
   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
   #+END_SRC

** Trailing whitespaces
   Always highlight trailing whitespaces for =prog-mode=, even though they are
   automatically deleted on save.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook '(lambda () (setq show-trailing-whitespace t)))
   #+END_SRC

** Indentation
   Always indent with spaces, unless specified
   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   Display tabs with a 2 characters width, to horrible nesting
   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 2)
   #+END_SRC

*** =highlight-indent-guide=
    From [[https://github.com/DarthFennec/highlight-indent-guides][here]].

    =highlight-indent-guide= makes indentation easier to understand with some
    sweet highlighting.
    #+BEGIN_SRC emacs-lisp
      (use-package highlight-indent-guides
        :diminish highlight-indent-guides-mode
        :hook ((prog-mode yaml-mode) . highlight-indent-guides-mode)
        :init
        (setq highlight-indent-guides-method 'character))
    #+END_SRC

*** =aggressive-indent=
    From [[https://github.com/Malabarba/aggressive-indent-mode][here]].

    This package is suppose to do a great job with code indentation, even during
    shitfing, transposing, slurping etc.

    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :hook (prog-mode . aggressive-indent-mode))
    #+END_SRC

** Case
   Treat lower/uppper CamelCase as separate words
   #+BEGIN_SRC emacs-lisp
     (use-package subword
       :diminish subword-mode
       :config
       (global-subword-mode 1))
   #+END_SRC
** Cursor width
   From [[http://pragmaticemacs.com/emacs/adaptive-cursor-width/][here]].
   Make the cursor the full width of the underlying character (TAB, etc).
   #+BEGIN_SRC emacs-lisp
     (setq x-stretch-cursor t)
   #+END_SRC
** Auto revert
   From [[http://pragmaticemacs.com/emacs/automatically-revert-buffers/][here]].
   Automatically update the buffer if the associated file on the disk has changed.
   If the buffer has unsaved changes, Emacs will prompt.
   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC
** Parens
   Automatically write the closing quote, bracket, parenthesisâ€¦ you know what I
   mean.
   Don't forget to disable =electric-pair-mode= for lispy languages,
   =smartparens= doest it instead.
   #+BEGIN_SRC emacs-lisp
     (electric-pair-mode t)
   #+END_SRC

   Support a few more pairs. (See [[http://ergoemacs.org/emacs/emacs_insert_brackets_by_pair.html][here]])
   #+BEGIN_SRC emacs-lisp
     (setq electric-pair-pairs
           '((?` . ?`)))
   #+END_SRC
** Sentence delimitation
   Sentence end with a single space. Because I said it.
   #+BEGIN_SRC emacs-lisp
     (setq sentence-end-double-space nil)
   #+END_SRC

** Folding
*** =hideshow=
    Emacs requires a mode to handle folding.
    Let's run with =hideshow=, which is built-in and really efficient.

    #+BEGIN_SRC emacs-lisp
      (use-package hideshow
        :diminish hs-minor-mode
        :hook (prog-mode . hs-minor-mode))
    #+END_SRC

*** =vimish-fold=
    From [[https://github.com/mrkkrp/vimish-fold][here]].\\
    This package provide Vim-like folds. That's pretty cool, I can do what I
    want, the folds are even persistent... but it's a bit less intuitive than
    =hideshow=. Since I don't fold much, I prefer =hideshow=.

    However, I'll keep the configuration, in case I want to give it a shot someday.
    #+BEGIN_SRC emacs-lisp
      ;; (use-package vimish-fold
      ;;   :init
      ;;   (setq vimish-fold-dir (concat user-emacs-directory "vimish-fold"))
      ;;   (setq vimish-fold-persist-on-saving t)
      ;;   :config
      ;;   (vimish-fold-global-mode t))
    #+END_SRC

    From [[https://github.com/alexmurray/evil-vimish-fold][here]].\\
    This package adds =evil= bindings for =vimish-fold=
    #+BEGIN_SRC emacs-lisp
      ;; (use-package evil-vimish-fold
      ;;   :defer t
      ;;   :config
      ;;   (evil-vimish-fold-mode t))
    #+END_SRC
** Selection
*** =expand-region=
    =expand-region= ([[https://github.com/magnars/expand-region.el][here]]) allows to expand the selection by semantic units...
    wathever that means.\\
    From what I undertand, it first selects the word, then the quote, the
    sentence, the block, etc... Sounds great.
    I probably can do the same with =visual= state of =evil=...

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :bind (
               ("C-M-=" . er/expand-region)
               ("C-M--" . er/contract-region)))
    #+END_SRC

*** =ace-jump-mode=
    I always loved Vim's =EasyMotion=, even though I never used it that much.
    Basically, it allows me to jump to the desired occurence of a word in the
    displayed content by just pressing a key.
    I guess it's never too late :)

    Just hit =C-c SPC=, hit the char you wanna search and enjoy !
    (By default, it will search for words. If you want to search chars, you can
    hit =C-u C-c SPC=, or even =C-u C-u C-c SPC= to search for lines)
    #+BEGIN_SRC emacs-lisp
      (use-package ace-jump-mode
        :bind (
               :map evil-normal-state-map
               ("C-c SPC" . ace-jump-mode)
               ("C-x SPC" . ace-jump-mode-pop-mark)))
    #+END_SRC
** Transpose
   Emacs has cool built-in feature to transpose stuff, such as
   =transpose-words=, =transpose-chars=, =transpose-lines=...
   Very usefull and kinda' new for a Vim guy.

   By default, only =M-t= (=transpose-words=) and =C-x C-t= (=transpose-lines=)
   are bound.

   Let's create a custom map to access all of them, with =C-x C-t= as prefix.
   I'll maybe have to type a few more keys, but since I don't use them that
   often, I won't mind.

   #+BEGIN_SRC emacs-lisp
     (bind-keys :prefix "C-x C-t"
                :prefix-map lrn/transpose-map
                :prefix-docstring "Keymap for transpose commands"
                ("w" . transpose-words)
                ("c" . transpose-chars)
                ("l" . transpose-lines)
                ("p" . transpose-paragraphs)
                ("e" . transpose-sexps)
                ("s" . transpose-sentences)
                ("r" . transpose-regions))
   #+END_SRC
** Align
*** =ialign=
    I often like to align stuff, like variables name, lists, numbers etc...
    Emacs provides few functions to do alignment.\\
    I found =ialign= ([[https://github.com/mkcms/interactive-align][here]]) to be a good alternative to =align-regexp=, as it has more functionalities.

    Let's bind it to =C-x C-a=.\\
    I like to apply the alignement on the whole line (i.e. align at each space).
    To disable the repetition, hit =C-c C-r=
    #+BEGIN_SRC emacs-lisp
      (use-package ialign
        :bind (
               :map evil-normal-state-map
               ("C-x C-a" . ialign))
        :init
        ;; Change the default regex to align by the first space
        (setq ialign-initial-regexp "\\( \\)")
        ;; I want to repeat the alignment throughout the lines
        (setq ialign-initial-repeat t))
    #+END_SRC
** =undo-tree=
   Emacs does almost everything well... except undos ! That's a nightmare
   compare to Vim.

   Hopefully, some guys try to make something 'similar' to Vim, despite the
   Emacs limitations.

   =undo-tree= provides a cool... undo-tree, with timestamps, persistent undo
   and such. Definitly not perfect, but better that nothing.
   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode
       :init
       ;; Set a cutom undo directory, and enable persistent undo
       (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "tmp/undo"))))
       (setq undo-tree-auto-save-history t)
       (setq undo-tree-visualizer-timestamps t)
       (setq undo-tree-visualizer-diff t)
       :config
       (progn
         (global-undo-tree-mode)))
   #+END_SRC
** =move-text=
   =move-text= allows to text up and down with =<M-up>= / =<M-down>=, like in VSCode
   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :config
       (move-text-default-bindings))
   #+END_SRC
** =rainbow-mode=
   Because it can be usefull to visualise the actual color of hex colors, not
   only in =CSS Mode=.
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :diminish rainbow-mode
       :hook (prog-mode . rainbow-mode))
   #+END_SRC
** Mark
   By default, =set-mark-command= is bound on =C-@= and =C-SPC=.\\
   =C-@= is totally unpractical, period.
   However, I prefere to use =C-SPC= to invoke =company-complete=, like Intellisence in VSCode.

   So, let's remap =set-mark-command=
   on =C-c C-SPC=, to match his brother =C-x C-SPC= (=pop-global-mark)
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "C-c C-SPC") 'set-mark-command)
   #+END_SRC

** Default mode
   I prefer =text-mode= over =fundamental-mode= as default =major-mode=.

   #+BEGIN_SRC emacs-lisp
     (setq-default major-mode 'text-mode)
   #+END_SRC
** Text
*** =refill-mode=
    I like to have a nice formatting to write text.\\
    =refill-mode= does a pretty good job to keep text wrapped, making nice
    paragraphs, by auto-filling at =fill-column= length.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'text-mode-hook 'refill-mode)
    #+END_SRC

    Let's add a shortcut to disable =refill-mode=, just in case.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c q") 'refill-mode)
    #+END_SRC
* Windows and buffers
** Kill this buffer
   Here's a small custom wrapper for =kill-buffer-and-window= /
   =kill-this-buffer=.

   If called without prefix, it kills the current buffer and window, otherwise, it
   just kills the buffer.

   #+BEGIN_SRC emacs-lisp
     (defun lrn/kill-this-buffer-and-window (arg)
       "Kill the current buffer and delete the selected window. If call with a preix argument, just kill the buffer."
       (interactive "P")
       (cond
        ((equal arg nil)
         (kill-buffer-and-window))
        (t
         (kill-this-buffer))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x k") 'lrn/kill-this-buffer-and-window)
   #+END_SRC

** Window splitting
   Thanks again @HRS for those functions, really useful to split windows in a
   more friendly fashion.

   Always switch to the new window after splitting
   #+BEGIN_SRC emacs-lisp
     (defun hrs/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun hrs/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))
   #+END_SRC

   Bind those 2 functions. I had to overwrite Evil map.
   #+BEGIN_SRC emacs-lisp
     (define-key evil-window-map "v" 'hrs/split-window-right-and-switch)
     (define-key evil-window-map "\C-v" 'hrs/split-window-right-and-switch)

     (define-key evil-window-map "s" 'hrs/split-window-below-and-switch)
     (define-key evil-window-map "S" 'hrs/split-window-below-and-switch)
     (define-key evil-window-map "\C-s" 'hrs/split-window-below-and-switch)
     (define-key evil-window-map (kbd "C-S-s") 'hrs/split-window-below-and-switch)
   #+END_SRC
** Scratch buffers
*** Mooooore !
    A cool HRS function to generate new scratch buffers.
    Can be used with =M-x hrs/generate-scratch-buffer= to create a scratch buffer
    in the current pane.
    #+BEGIN_SRC emacs-lisp
      (defun hrs/generate-scratch-buffer ()
        "Create and switch to a temporary scratch buffer with a random
             name."
        (interactive)
        (switch-to-buffer (make-temp-name "scratch-")))
    #+END_SRC

    I want to be able to spawn scratch buffers in a new split-window, horizontal
    or vertical.
    Let's make a small keymap on =C-w C-n= (instead of =evil-window-new=), and
    bind two custom functions to do what I want, A.K.A, spawning a horizontal-split
    scratch buffer with =C-w C-n s=, and a vertical-split one with =C-w C-n v=

    First, a function to spawn the scratch buffers
    #+BEGIN_SRC emacs-lisp
      (defun lrn/spawn-scratch-buffer (orientation)
        "Spawn a scratch buffer in a new window. Orientation can be either 'horizontal' or 'vertical'"
        (cond ((eq orientation 'horizontal) (hrs/split-window-below-and-switch))
              ((eq orientation 'vertical) (hrs/split-window-right-and-switch)))
        (hrs/generate-scratch-buffer))
    #+END_SRC

    And two other function to spawn vertically or horizontaly (At first, I tried
    to make lambdas, it works great, but then =guide-key= displays ?? as the
    function name...)
    #+BEGIN_SRC emacs-lisp
      (defun lrn/spawn-scratch-buffer-horizontal ()
        (interactive)
        (lrn/spawn-scratch-buffer 'horizontal))

      (defun lrn/spawn-scratch-buffer-vertical ()
        (interactive)
        (lrn/spawn-scratch-buffer 'vertical))
    #+END_SRC

    Then, the map and the bindings
    #+BEGIN_SRC emacs-lisp
      ;; Unbind C-w C-n (evil-new-window)
      (define-key evil-motion-state-map (kbd "C-w C-n") nil)

      (bind-keys :map evil-window-map
                 :prefix "C-n"
                 :prefix-map lrn/scratchbuffer-map
                 :prefix-docstring "Keymap for splitted scratchbuffers."
                 ("s" . lrn/spawn-scratch-buffer-horizontal)
                 ("v" . lrn/spawn-scratch-buffer-vertical))
    #+END_SRC

*** =persistent-scratch=
    Thanks to [[https://github.com/Fanael/persistent-scratch][this]] package, I can have persistent scratch buffers. They are
    automatically saved and restored with Emacs.\\
    That's cool when I mess around with scratch buffers and I don't want to lose
    them, since I have the tendency to close Emacs quite frequently.

    By default, only the buffers named =*scratch*= are saved. I also want to save
    the scratch buffer that I spawn.
    Let's fix that.

    Fist, define a custom check function to match all scratch buffers.
    #+BEGIN_SRC emacs-lisp
      (defun lrn/persistent-scratch-custom-scratch-buffer-p ()
        "Return non-nil iff the current buffer's name is a scratch one"
        (or
         (string= (buffer-name) "*scratch*")
         (string-match "^scratch-[A-Za-z0-9]\\{6\\}$" (buffer-name))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package persistent-scratch
        :init
        ;; Use my custom function to check buffers name to know what to save
        (setq persistent-scratch-scratch-buffer-p-function 'lrn/persistent-scratch-custom-scratch-buffer-p)
        :config
        (progn
          (persistent-scratch-setup-default)))
    #+END_SRC
** =winner-mode=
   Allow to switch back and forth between window configuration with =C-c <left>=
   and =C-c <right>=!
   So useful.
   #+BEGIN_SRC emacs-lisp
     (winner-mode t)
   #+END_SRC
** Kill all other buffers
   From [[https://stackoverflow.com/a/14161165][here]].
   A usefull function to do some cleanup when I'm having t many open
   buffers and that I'm too lazy to kill them in =C-x C-b= (=ibuffer=)

   TODO: Find a good binding for it :)
   #+BEGIN_SRC emacs-lisp
     (defun lrn/kill-other-buffers ()
       (interactive)
       (mapc 'kill-buffer (cdr (buffer-list (current-buffer)))))
   #+END_SRC
** Manage buffers
*** =ibuffer=
    I really like =helm-mini= to quickly find a buffer or re-open a recently
    close file. But when it comes to manage multiple buffers at the same time...
    I can't get used to it's shitty bindings.\\
    I prefer =ibuffer=, who comes with =dired= like bindings, group features and
    so much more.

    There's some cool tweaks to make =ibuffer= even cooler. See [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][here]] !

    Here's a helper function stolen from @[[https://github.com/purcell/emacs.d/blob/master/lisp/init-ibuffer.el#L10][purcell]]'s conf (see [[https://github.com/purcell/emacs.d/blob/master/lisp/init-ibuffer.el#L10][here]]) to enable
    =ibuffer-vc= filter groups.
    #+BEGIN_SRC emacs-lisp
      (defun lrn/ibuffer-set-up-preferred-filters ()
        (interactive)
        (ibuffer-vc-set-filter-groups-by-vc-root)
        (unless (eq ibuffer-sorting-mode 'filename/process)
          (ibuffer-do-sort-by-filename/process)))
    #+END_SRC

    Let's configure =ibuffer=.\\
    I also add =ibuffer-vc= (see [[https://github.com/purcell/ibuffer-vc][here]]) to group buffers by VC root. It's usefull
    to easily know which buffer belongs to which project, without being in a
    =Projectile= thing.
    #+BEGIN_SRC emacs-lisp
      (use-package ibuffer
        :hook (
               ;; Enable ibuffer-auto-mode to auto-refresh buffer if changes occur on the disk
               (ibuffer . ibuffer-auto-mode)
               ;; Enable ibuffer-vc filter groups when I open ibuffer
               (ibuffer . lrn/ibuffer-set-up-preferred-filters))
        :bind (("C-x C-b" . ibuffer))
        :init
        (use-package ibuffer-vc)
        ;; Hide empty filter-groups
        (setq ibuffer-show-empty-filter-groups nil)
        ;; Here's a custom filter-group, in case I don't want ibuffer-vc filtering,
        ;; but style have some groups I like.
        (setq ibuffer-saved-filter-groups
              '(("basic"
                 ("Org" (mode . org-mode))
                 ("Magit" (name . "^magit:*"))
                 ("Helm" (name . "^\*helm*"))
                 )))
        :config
        (progn
          ;; Let's create a custom column with file size displayed in a human-redeable
          ;; style...
          (define-ibuffer-column size-h
            (:name "Size" :inline t)
            (cond
             ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
             ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
             (t (format "%8d" (buffer-size)))))
          ;; ... then apply it by redefining ibuffer-formats.
          (setq ibuffer-formats
                '((mark modified read-only " "
                        (name 18 18 :left :elide)
                        " "
                        (size-h 9 -1 :right)
                        " "
                        (mode 16 16 :left :elide)
                        " "
                        filename-and-process)))
          ;; I want to be able to switch back to ibuffer-vc filter-groups in ibuffer,
          ;; if I disabled them.
          (evil-define-key 'normal ibuffer-mode-map (kbd "s V") 'lrn/ibuffer-set-up-preferred-filters)
          ))
    #+END_SRC

* Workspaces
  I just discovered that I can have workspaces in Emacs, just like in i3WM.\\
  I have to try this ! However I'm not sure what package to chooose, between
  =perspective.el=, =persp-mode= and =eyebrowse=...

  I also don't know how they interact with =projectile=.
  Let's try them all and see !

** =eyebrowse=
   From [[https://github.com/wasamasa/eyebrowse][here]]. Ressources [[http://pragmaticemacs.com/emacs/easily-manage-emacs-workspaces-with-eyebrowse/][here]],

   This package workspaces to Emacs, just like a TWM.
   Hit =C-c C-w=, then you can choose a workspace (0-9).\\
   Each workspace keeps a different window configuration, and it's saved by
   =desktop-save-mode=. Pretty cool.

   Apparently, it can work with =perspective=, with some additional code (see
   [[https://www.reddit.com/r/emacs/comments/6sffrd/am_i_misunderstanding_eyebrowse/dlcfhwk][here]]), so you can have multiple workspaces with 10 sub-workspaces in each
   one... Sounds great, but I don't find the proper way to do it.


   #+BEGIN_SRC emacs-lisp
     (use-package eyebrowse
       :bind (
              ;; That's stupid, I need to include the prefix in the binding... bug ?
              :map eyebrowse-mode-map
              ("C-c C-w <left>" . eyebrowse-prev-window-config)
              ("C-c C-w <right>" . eyebrowse-next-window-config))
       :init
       ;; This is a custom face, so the active workspace is more visible in the mode-line.
       (set-face-attribute 'eyebrowse-mode-line-active nil
                           :inherit font-lock-builtin-face
                           :weight 'bold)
       ;; Circle through the workspaces.
       (setq eyebrowse-wrap-around t)
       ;; Create a scratch buffer in a new workspace.
       (setq eyebrowse-new-workspace 'hrs/generate-scratch-buffer)
       ;; Set the prefix to access eyebrowse-keymap
       (setq eyebrowse-keymap-prefix (kbd "C-c C-w"))
       ;; Always show the mode-line indicator, even if there's only one workspace
       (setq eyebrowse-mode-line-style t)
       :config
       (eyebrowse-mode t))
   #+END_SRC

* =TRAMP=
  =TRAMP= is great to remote-edit files with Emacs !
  I need to use it way more.

  Use =ssh= by default
  #+BEGIN_SRC emacs-lisp
    (setq tramp-default-method "ssh")
  #+END_SRC
* =Org-mode=
** =org=
   Let's install the latest =org= package and set some stuff.
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :hook (
              (org-mode . (lambda ()
                            (setq show-trailing-whitespace t)
                            (refill-mode -1)
                            (auto-fill-mode t))))
       :init
       ;; Syntax highlight src blocks in org-mode
       (setq org-src-fontify-natively t)
       ;; Make tab work like in a code buffer for src blocks
       (setq org-src-tab-acts-natively t)
       ;; Use anothr window when editing a code snippet
       (setq org-src-window-setup 'other-window)
       ;; Log the date when a TODO is DONE
       (setq org-log-done 'time)
       ;; Remove footer when exporting in HTML mode
       (setq org-html-postamble nil))
   #+END_SRC
** Babel
   Allow Babel to evaluate these languages
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (ruby . t)
        (dot . t)
        (shell . t)
        (python . t)
        (gnuplot . t)))
   #+END_SRC

   Dont ask permission to run code blocks
   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   Disable the checkdock warnings for =emacs-lisp= code blocks.
   It floods the =modeline=... See [[https://emacs.stackexchange.com/a/16770][here]].
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-src-mode-hook
               (lambda ()
                 (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc))))
   #+END_SRC
** Bullets
   It's way cooler to have graphicals bullets instead of plains *, don't you
   think ?
   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :hook (org-mode . org-bullets-mode))
   #+END_SRC
** Exports
   One of the best feature of =Org-mode= is it's capability to export org-files
   in a shitload of format !

   Want some markdown ?
   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
   #+END_SRC

   Want Beamer ?
   #+BEGIN_SRC emacs-lisp
     (require 'ox-beamer)
   #+END_SRC

   Want some f*cking Twitter Bootstrap ?
   #+BEGIN_SRC emacs-lisp
     (use-package ox-twbs)
   #+END_SRC

   Because it's cool to have nice text decorations in HTML
   #+BEGIN_SRC emacs-lisp
     (use-package htmlize)
   #+END_SRC

   Settings for LaTeX (WIP, tested on Linux, not OSX)
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     (setq org-latex-listings 'minted)
     (setq org-latex-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
   #+END_SRC

** Global bindings
   Because sometimes =org-mode= features are so great, I want to use them in
   every other mode !

   Let's make =org-open-at-point= globally available
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "C-c C-o") 'org-open-at-point-global)
   #+END_SRC
* Programming
  I will put a lot of stuff in this section, sometimes not justified at all !
  But I don't know how to organize everything...

** Environment, PATH and stuff
*** PATH
    When Emacs is not run from a shell, it doesn't inherit from the user's PATH
    defined in his shell config.
    But there's package to fix that :)
    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
        :config
        (progn
          (when (memq window-system '(mac ns nil))
            (exec-path-from-shell-initialize))))
    #+END_SRC
** VCS
   Everything needed to work with =Git= in the best conditions
*** =magit=
    =magit= is greaaaaaaat. So much great ! Every other Git client can get back at
    their moms house.
    Just hit =C-x g= (=magit-status=) and let the magic operate.

    I also add =evil-magit= to have =evil= bindings within =magit=
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :hook (
               (with-editor-mode . evil-insert-state))
        :bind (
               ("C-x g" . magit-status))
        :config
        (use-package evil-magit))
    #+END_SRC
*** =gist=
    A cool package to manage gists directly from within Emacs
    #+BEGIN_SRC emacs-lisp
      (use-package gist
        :bind (
               :map gist-list-menu-mode-map
               ("s" . gist-list-starred)
               ("u" . gist-list-user)
               ("t" . gist-list-push-tag-limit)
               ("p" . gist-list-push-visibility-limit)
               ("x" . gist-list-pop-limit)))
    #+END_SRC

    Let's make an =hydra= to have convenient bindings for all this cool =gist=
    commands !
    #+BEGIN_SRC emacs-lisp
      (defhydra lrn/hydra-make-gist (
                                     :hint nil
                                     :color blue
                                     :foreign-keys run)
        "
       ^Create private^  |  ^Create public^  |     ^List^    |    ^Other^
      ^^^^^^--------------------------------------------------------------
        [_r_] Region     |  [_R_] Region     | [_l_] All     |  [_q_] Quit
        [_b_] Buffer     |  [_B_] Buffer     | [_s_] Starred |
        ^^^^                                 | [_u_] User    |
      "
        ("r" gist-region-private)
        ("b" gist-buffer-private)
        ("R" gist-region)
        ("B" gist-buffer)
        ("l" gist-list)
        ("s" gist-list-starred)
        ("u" gist-list-user)
        ("q" nil))
      (bind-key "g" 'lrn/hydra-make-gist/body lrn/custom-map)
    #+END_SRC

    #+RESULTS:
    : lrn/hydra-make-gist/body

    I also need an hydra to help me remember all the =gist-list-mode= bindings.
    #+BEGIN_SRC emacs-lisp
      (defhydra lrn/hydra-gist-list-mode (
                                          :hint nil
                                          :color blue
                                          :foreign-keys run)
        "
            ^Edit^      |      ^Url^     |     ^Star^^^   |   ^Limit^     |   ^Other^
      ^^^^^^^^^^------------------------------------------------------------------------------------
      [_+_] Add buffer  | [_y_] Copy url | [_*_]^^ Star   | [_s_] Starred | [_RET_] Fetch (focus)
      [_-_] Remove file | [_b_] Browse   | [_\\^_] Unstar | [_u_] User    | [_TAB_] Fetch (no focus)
      [_e_] Edit desc.  |                           ^^^^^^| [_t_] Tag     | [_f_]   Fork
      [_k_] Kill        |                           ^^^^^^| [_p_] Public  | [_g_]   Reload
                                                  ^^^^^^^^| [_x_] Pop     | [_q_]   Quit
      "
        ("+" gist-add-buffer)
        ("-" gist-remove-file)
        ("e" gist-edit-current-description)
        ("k" gist-kill-current)
        ("y" gist-print-current-url)
        ("b" gist-browse-current-url)
        ("*" gist-star)
        ("^" gist-unstar)
        ("s" gist-list-starred)
        ("u" gist-list-user)
        ("t" gist-list-push-tag-limit)
        ("p" gist-list-push-visibility-limit)
        ("x" gist-list-pop-limit)
        ("RET" gist-fetch-current)
        ("TAB" gist-fetch-current-noselect)
        ("f" gist-fork)
        ("g" gist-reload)
        ("q" nil))
      (with-eval-after-load 'gist
        (bind-key "h" 'lrn/hydra-gist-list-mode/body gist-list-menu-mode-map))
    #+END_SRC

*** =git-gutter=
    Another Sublime package that I really like, makes atomic commits and partial
    staging so much easier.
    #+BEGIN_SRC emacs-lisp
      (use-package git-gutter-fringe
        :diminish git-gutter-mode
        :config
        (global-git-gutter-mode 1))

    #+END_SRC
** Fuzzy-finding and search
*** =helm-swoop=
    From [[https://github.com/ShingoFukuyama/helm-swoop][here]].
    =helm-swoop=, to do search in the buffers !
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm-swoop
      ;;   :bind (
      ;;          ("M-i" . helm-swoop)
      ;;          ("M-I" . helm-swoop-back-to-last-point)
      ;;          ("C-c M-i" . helm-multi-swoop)
      ;;          ("C-x M-i" . helm-multi-swoop-all)
      ;;          :map isearch-mode-map
      ;;          ("M-i" . helm-swoop-from-isearch)
      ;;          :map helm-swoop-map
      ;;          ("M-i" . helm-multi-swoop-all-from-helm-swoop))
      ;;   :config
      ;;   (progn
      ;;     (setq helm-swoop-split-with-multiple-windows t)
      ;;     (setq helm-swoop-split-direction 'split-window-horizontally)))
    #+END_SRC
*** =swiper=
    From [[https://oremacs.com/swiper/][here]].\\
    The fuzzy-finder based on =ivy=

    To search for the symbol-at-point, hit =M-n= after entering =swiper=.
    #+BEGIN_SRC emacs-lisp
      (use-package swiper
        :bind (
               ("M-i" . swiper)))
    #+END_SRC
*** =ag=
    =ag=, AKA The Silver Searcher, is great to find stuff in files. Specially
    with =projectile=, tu search in a whole project.

    It requires the "[[https://github.com/ggreer/the_silver_searcher][the_silver_searcher]]" binary installed on the system to
    work.
    #+BEGIN_SRC emacs-lisp
      (use-package ag)
    #+END_SRC
*** =isearch=
    I want to be able to navigate in =isearch-ring= to quickly use a previous
    pattern again, using =<up>= and =down=. See [[https://emacs.stackexchange.com/a/31336][here]].

    #+BEGIN_SRC emacs-lisp
      (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat)
      (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance)
    #+END_SRC

    Show the match count.
    #+BEGIN_SRC emacs-lisp
      (setq isearch-lazy-count t)
    #+END_SRC
** Project management
*** =projectile=
    =projectile= is another awesome package, allowing us to work with projects
    instead of just folders. So much possibilities, I still have a lot to learn
    about it.

    Here'a another @HRS function to use =ag= with =projectile= to search the
    symbol at point across the project.
    #+BEGIN_SRC emacs-lisp
      (defun hrs/search-project-for-symbol-at-point ()
        "Use `projectile-ag' to search the current project for `symbol-at-point'."
        (interactive)
        (projectile-ag (projectile-symbol-at-point)))
    #+END_SRC

    Behold, =projectile= ! With bindings for =ag= and integration with =neotree=
    and =helm=
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :diminish projectile-mode
        :bind (
               :map projectile-mode-map
               ("C-c C-p s v" . hrs/search-project-for-symbol-at-point)
               ("C-c C-p" . projectile-command-map))
        :init
        (setq projectile-require-project-root nil)
        :config
        (progn
          (setq projectile-switch-project-action 'neotree-projectile-action)
          (setq projectile-keymap-prefix (kbd "C-c C-p"))
          (projectile-mode t)))
    #+END_SRC

    +Speaking of =helm=, don't forget =helm-projectile= ([[https://github.com/bbatsov/helm-projectile][here]]). See [[http://tuhdo.github.io/helm-projectile.html][here]].+
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm-projectile)
    #+END_SRC

    From [[https://github.com/ericdanan/counsel-projectile][here]]. Integrate =ivy=/=counsel= stuff into =projectile=
    #+BEGIN_SRC emacs-lisp
      (use-package counsel-projectile
        :config
        (counsel-projectile-mode))
    #+END_SRC
** Completion
*** =company=
    =company= is a completion framework pluggable with different backends to
    provide a cool completion during programming.
    I need to configure the popup style, because for now it looks like Windows
    95... but it works great !

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :diminish (company-mode "Company")
        :bind (
               ("C-SPC" . company-complete)
               :map company-active-map
               ("?" . company-show-doc-buffer)
               ("<down>" . company-complete-common-or-cycle)
               ("M-n" . company-complete-common-or-cycle)
               ("M-j" . company-complete-common-or-cycle)
               ("C-n" . company-complete-common-or-cycle)
               ("C-j" . company-complete-common-or-cycle)
               ("<escape>" . company-abort)
               ("<tab>" . company-complete-selection))
        :init
        (setq company-tooltip-limit 30)                        ; bigger popup window
        (setq company-idle-delay 0)                          ; decrease delay before autocompletion popup shows
        (setq company-echo-delay 0)                            ; remove annoying blinking
        (setq company-begin-commands '(self-insert-command))   ; start autocompletion only after typing
        (setq company-minimum-prefix-length 1)
        (setq company-tooltip-align-annotations t)
        :config
        (progn
          (global-company-mode)))
    #+END_SRC
*** =company-quickhelp=
    It's nice to have small popups with the documentation of the candidates in
    =company= :)
    #+BEGIN_SRC emacs-lisp
      (use-package company-quickhelp
        :init
        (setq company-quickhelp-delay 0.5)
        (setq company-quickhelp-use-propertized-text t)
        :config
        (company-quickhelp-mode))
    #+END_SRC
** Snippets
*** =yasnippet=
    From [[https://github.com/joaotavora/yasnippet][here]]. Ressouces [[https://www.emacswiki.org/emacs/Yasnippet][here]], [[http://ergoemacs.org/emacs/emacs_templates.html][here]], [[http://pragmaticemacs.com/emacs/smart-text-templates-with-yasnippet/][here]], [[http://pragmaticemacs.com/emacs/smart-text-templates-with-yasnippet/][here]].

    TextMate-like snippets in Emacs ! I usually don't use a lot of snippets, but
    for very-repetitive stuff like control-structures, I have to admit, it's
    usefull.

    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :init
        (setq yas-snippet-dirs `(,(concat user-emacs-directory "snippets")))
        :config
        (yas-global-mode t))
    #+END_SRC
** Documentation
*** =eldoc=
    =eldoc= shows the prototype of the function at point in the echo area.
    By default it only works for Lisp, but you can plug additional backends to
    support other languages. It's really nifty.

    Let's enable it globally
    #+BEGIN_SRC emacs-lisp
      (use-package eldoc
        :diminish (eldoc-mode "eldoc")
        :config
        (global-eldoc-mode t))
    #+END_SRC
** Syntax checking
*** =flycheck=
    A great realtime syntax checking extension that works with a lot of
    backends.

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :config
        (progn
          (global-flycheck-mode)))
    #+END_SRC
*** =ivy-yasnippet=
    From [[https://github.com/mkcms/ivy-yasnippet][here]].\\
    This package provides snippet preview using =ivy=.

    #+BEGIN_SRC emacs-lisp
      (use-package ivy-yasnippet
        :bind ("C-c & i" . ivy-yasnippet))
    #+END_SRC
** Languages
*** YAML
    A major mode to edit YAML files :) Pretty good, with syntax highlighting,
    correct indenting etc...
    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode)
    #+END_SRC
*** JSON
    Here's a major-mode ([[https://github.com/joshwnj/json-mode][here]]) to edit JSON, with syntax highlithing, indentation,
    linting etc :)
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode)
    #+END_SRC
*** CMake
    A major mode for CMake files
    #+BEGIN_SRC emacs-lisp
      (use-package cmake-mode)
    #+END_SRC
*** Lisp
    Lisp, Emacs Lisp, Clojure... it's all the same for me ! I put eveything here.
**** =smartparens=
     According to [[https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html#fnr.75][this]], =smartparens= ([[https://github.com/Fuco1/smartparens][here]]) is cooler than =paredit=, which I used so
     far (only for lispy languages)
     Let's give it a shot, it's always nice to have a good expression
     management... and it works with other pairs too ! Quotes, brackets and stuff.

     Maybe someday I'll get some ideas from [[http://pages.sachachua.com/.emacs.d/Sacha.html#orgdd725d2][here]] too :)
     #+BEGIN_SRC emacs-lisp
       (use-package smartparens
         :diminish smartparens-mode
         :config
         (progn
           (sp-use-smartparens-bindings)
           ;; Disable the highlight when spawning a pair, it doesn't go away
           ;; until exiting Insert mode or hitting backspace...
           (setq sp-highlight-pair-overlay nil)
           (require 'smartparens-config)))
     #+END_SRC

**** Parenthesis much ?
     All you need to avoid killing yourself when working with SO MUCH parenthesis
     !

     =rainbow-delimiters= colors each pair of paranthesis in a different color.
     It helps A LOT with readability issues.
     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-delimiters)
     #+END_SRC

     There's also a lot a mode for editings \*lisp\*, so we need to enable
     =smartparens= and =rainbow-delimiters= for everyone of them.
     #+BEGIN_SRC emacs-lisp
       (setq lispy-mode-hooks
             '(clojure-mode-hook
               emacs-lisp-mode-hook
               lisp-mode-hook))

       (dolist (hook lispy-mode-hooks)
         (add-hook hook (lambda ()
                          (setq show-paren-style 'expression)
                          (electric-pair-local-mode -1)
                          (smartparens-strict-mode)
                          (show-smartparens-mode)
                          (rainbow-delimiters-mode))))
     #+END_SRC
**** Eval
     Evaluating lisp expressions to do stuff is great. I'm not sure if the
     following content is at the right place, it could also be in =Editing=...
     But it doesn't matter for now.

***** Eval prefix
      By default, there's only one content-evalutation binding, =C-x C-e= (=eval-last-sexp=)
      I'd like to also have binding for =eval-buffer=, =eval-region= and
      stuff.\\
      So let's make =C-x C-e= a prefix, and redefine some binding, should we ?

      #+BEGIN_SRC emacs-lisp
        (bind-keys :prefix "C-x C-e"
                   :prefix-map lrn/eval-map
                   :prefix-docstring "Keymap for evaluation commands"
                   ("e" . eval-last-sexp)
                   ("b" . eval-buffer)
                   ("r" . eval-region)
                   ("p" . eva-print-last-sexp)
                   ("d" . eval-defun))
      #+END_SRC

***** Eval and replace
      From [[https://emacsredux.com/blog/2013/06/21/eval-and-replace/][here]].\\
      This is GREAT. This function allows me to evaluate some s-exp and insert the
      output instead. Now I just need to learn some cool lisp stuff ^^'
      #+BEGIN_SRC emacs-lisp
        (defun lrn/eval-and-replace ()
          "Replace the preceding sexp with its value."
          (interactive)
          (backward-kill-sexp)
          (condition-case nil
              (prin1 (eval (read (current-kill 0)))
                     (current-buffer))
            (error (message "Invalid expression")
                   (insert (current-kill 0)))))
      #+END_SRC

      Let's bind this function on the =C-x C-e= map
      #+BEGIN_SRC emacs-lisp
        ;; C-x C-e s (eval-last-sexp)
        (define-key lrn/eval-map (kbd "s") 'lrn/eval-and-replace)
      #+END_SRC
*** Python
    My Python setup, working smoothly but definitly not perfect. Based on [[https://realpython.com/emacs-the-best-python-editor/#pep8-compliance-autopep8][this]]
    article, but not only.
    I will improve it little by little.

    This setup requires some python packages to works.
    Make sure to install them in so =elpy= can find them
    #+BEGIN_SRC sh
      pip install jedi rope autopep8 yapf black flake8
    #+END_SRC

**** =pipenv=
     A package that provides bindings for =pipenv=, cool for working with
     virtual envs.
     It's hard to find a good solution when it comes to venv in Emacs, most of
     the package rely on =pyenv=, =pyvenv= or wathever, but not on =pipenv=,
     which is the official recommendation =/ So for now it's kind of glitchy,
     half =pipenv=, half =pyvenv=...
     #+BEGIN_SRC emacs-lisp
       (use-package pipenv
         :hook (python-mode . pipenv-mode)
         :bind (
                :map pipenv-command-map
                ("w" . pyvenv-workon))
         :init
         (setenv "WORKON_HOME" "~/.local/share/virtualenvs")
         (setq
          pipenv-projectile-after-switch-function
          #'pipenv-projectile-after-switch-extended)
         ;; Change the pipenv prefix, conflict with Projectile
         (setq pipenv-keymap-prefix (kbd "C-c p")))
     #+END_SRC
**** =company-jedi=
     A backend for =company= powered by =jedi=. Pretty cool.

     #+BEGIN_SRC emacs-lisp
       (defun lrn/python-company-hook ()
         (jedi:setup)
         (add-to-list 'company-backends 'company-jedi))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (use-package company-jedi
         :hook ((python-mode . lrn/python-company-hook))
         :init
         (setq jedi:complete-on-dot t)
         (setq pyvenv-post-activate-hooks (lambda ()
                                            (elpy-rpc--disconnect)
                                            (jedi:stop-server)
                                            )))
     #+END_SRC
**** =elpy=
     =elpy= is THE Python IDE for Emacs. It can do a lot of stuff and I need to
     learn a lot more about it.
     #+BEGIN_SRC emacs-lisp
       (use-package elpy
         :bind (
                :map elpy-mode-map
                ;; Unbind C-c C-p to avoid conflict with Projectile prefix
                ("C-c C-p" . nil))
         :config
         (progn
           (elpy-enable)
           ;; Disable elpy company-backend, conflict with jedi
           (remove-hook 'elpy-modules 'elpy-module-company)
           ;; Disable elpy-flymake, conflict with flycheck
           (remove-hook 'elpy-modules 'elpy-module-flymake)))
     #+END_SRC

     TODO: As of today, when I want to run a Python script with
     =elpy-shell-send-region-or-buffer=, I get the following error :
     #+BEGIN_QUOTE
     Warning (python): Your â€˜python-shell-interpreterâ€™ doesnâ€™t seem to support
     readline, yet â€˜python-shell-completion-native-enableâ€™ was t and "python" is not
     part of the â€˜python-shell-completion-native-disabled-interpretersâ€™ list.  Native
     completions have been disabled locally.
     #+END_QUOTE
     According to [[https://github.com/jorgenschaefer/elpy/issues/887][this]], it seems to be a well known bug. And there's no solution
     yet.
     So, to avoid being spammed by warning, let's disable the native completion
     for python.
     #+BEGIN_SRC emacs-lisp
       (setq python-shell-completion-native-disabled-interpreters '("python"))
     #+END_SRC
**** =autopep8=
     Automatic format and correction of PEP8 errors at save.
     Not 100% convince, but I keep it for now.

     #+BEGIN_SRC emacs-lisp
       (use-package py-autopep8
         :hook (elpy-mode . py-autopep8-enable-on-save))
     #+END_SRC

*** C / CPP
    I haven't decide yet between =rtags= and =irony=.
    From what I've read, =rtags= is more powerfull but also a LOT more ressource
    consuming... So meeeh.
    Thanks to @martinsosic for [[http://martinsosic.com/development/emacs/2017/12/09/emacs-cpp-ide.html][this]] great article.

**** Indentation
     Indent with tabs for C/CPP files, displayed as 4 spaces.
     #+BEGIN_SRC emacs-lisp
       (setq-default c-basic-offset 4)

       (add-hook 'c-mode-hook (lambda ()
                                (setq tab-width 4)
                                (setq evil-shift-width 4)
                                (setq indent-tabs-mode t)))
     #+END_SRC

     Set C coding style to "linux" to not indent braces in C files
     #+BEGIN_SRC emacs-lisp
       (setq-default c-default-style "linux")
     #+END_SRC
**** =irony=
     The core of this setup
     #+BEGIN_SRC emacs-lisp
       ;; (use-package irony
       ;;   :hook (
       ;;          ((c++-mode c-mode) . irony-mode)
       ;;          (irony-mode . irony-cdb-autosetup-compile-options))
       ;;   :init
       ;;   ;; Use compilation database first, clang_complete as fallback.
       ;;   (setq-default irony-cdb-compilation-databases '(irony-cdb-libclang
       ;;                                                     irony-cdb-clang-complete))
       ;;   :config
       ;;   (progn
       ;;     ;; If irony server was never installed, install it.
       ;;     (unless (irony--find-server-executable) (call-interactively #'irony-install-server))))
     #+END_SRC

     =irony= based =company= backend, for completion
     #+BEGIN_SRC emacs-lisp
       ;; (use-package company-irony
       ;; :config
       ;; (progn
       ;; (eval-after-load 'company '(add-to-list 'company-backends 'company-irony))))
     #+END_SRC

     =irony= based =flycheck= backend, for syntax checking
     #+BEGIN_SRC emacs-lisp
       ;; (use-package flycheck-irony
       ;;   :hook (flycheck-mode . flycheck-irony-setup))
     #+END_SRC

     =irony= based =eldoc= backend, for documentation
     #+BEGIN_SRC emacs-lisp
       ;; (use-package irony-eldoc
       ;;   :hook (irony-mode . irony-eldoc))
     #+END_SRC

**** =rtags=
     =rtags= need some binaries to work: rc and rdm.

     #+BEGIN_SRC emacs-lisp
       (use-package rtags
         :hook (
                ;; Start rdm process on entering C/CPP/ObjC modes
                ((c-mode c++-mode objc-mode) . rtags-start-process-unless-running)
                ;; Shutdown rdm when leaving emacs.
                (kill-emacs . rtags-quit-rdm))
         :bind (
                :map c-mode-base-map
                ("M-." . rtags-find-symbol-at-point)
                ("M-," . rtags-find-references-at-point)
                ("M-?" . rtags-display-summary))
         :init
         ;; Needed to avoid Emacs freeze when calling find-symbol
         (setq rtags-rdm-process-use-pipe t)
         :config
         (progn
           (unless (rtags-executable-find "rc") (error "Binary rc is not installed!"))
           (unless (rtags-executable-find "rdm") (error "Binary rdm is not installed!"))
           (rtags-enable-standard-keybindings)))
     #+END_SRC

-     =rtags= integration for =ivy=, to search definitions, I guess.
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-rtags
         :init
         (setq rtags-display-result-backend 'ivy))
     #+END_SRC

     =rtags= =company= backend for completion
     #+BEGIN_SRC emacs-lisp
       (use-package company-rtags
         :init
         (setq rtags-autostart-diagnostics t)
         (setq rtags-completions-enabled t)
         :config
         (progn
           (rtags-diagnostics)
           (push 'company-rtags company-backends)))
     #+END_SRC

     helper function to setup =flycheck-rtags=, apparently needed to ensure that
     only rtags is used for checking. See [[https://github.com/Andersbakken/rtags#optional-1][here]]
     #+BEGIN_SRC emacs-lisp
       (defun setup-flycheck-rtags ()
         (flycheck-select-checker 'rtags)
         (setq-local flycheck-highlighting-mode nil) ;; RTags creates more accurate overlays.
         (setq-local flycheck-check-syntax-automatically nil)
         (setq-local rtags-autostart-diagnostics t)
         (rtags-set-periodic-reparse-timeout 1)  ;; Run flycheck 2 seconds after being idle.
         )
     #+END_SRC

     =rtags= =flycheck= backend for syntax checking
     #+BEGIN_SRC emacs-lisp
       (use-package flycheck-rtags
         :hook ((c-mode c++-mode) . setup-flycheck-rtags))
     #+END_SRC

**** Misc
     These are test settings for C/CPP, to remove.
     #+BEGIN_SRC emacs-lisp
       ;; (require 'semantic)
       ;; (require 'semantic/bovine/gcc)
       ;; (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
       ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-local-symbol-highlight-mode)
       ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
       ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-summary-mode)
       ;; (semantic-mode 1)
       ;; (global-ede-mode t)
       ;; (ede-enable-generic-projects)
     #+END_SRC
*** HTML
    Because editing HTML markup is my FAVORITE thing ever in development... I
    better have some cools packages to help me do it !

**** =emmet-mode=
     From [[https://github.com/smihica/emmet-mode][here]].
     Big-up to Adrien !
     Just kidding, =Emmet= is great for people like me who dislike writing HTML
     and/or CSS.
     Even just to write a base HTML 5 template... so much time saved !

     In =web-mode=, hit =C-j= to expand =emmet= snippets\\
     #+BEGIN_SRC emacs-lisp
       (use-package emmet-mode
         :after web-mode
         :bind (
                :map web-mode-map
                ("C-j" . emmet-expand-line)))
     #+END_SRC

**** =web-mode=
     From [[http://web-mode.org/][here]].
     =web-mode= allows me to edit HTML templates with cool features.

     TODO: Support all needed file types, Company.
     #+BEGIN_SRC emacs-lisp
       (use-package web-mode
         :mode ("\\.html?\\'" "\\.tpl\\.php\\'")
         :hook (
                (web-mode . emmet-mode)
                (web-mode . rainbow-mode))
         :init
         (setq web-mode-markup-indent-offset 2))
     #+END_SRC
*** JavaScript
    Aaaaah JavaScript <3 My old best friend... You'll always have a special
    place in my heart.

    Let's configure a decent IDE for you, you deserve it !\\
    I'm (mostly) using [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html][this]] guide. (See also [[https://blog.onionstudio.com.tw/emacs-for-javascript/][here]])

**** =js2-mode=
     From [[http://elpa.gnu.org/packages/js2-mode.html][here]].\\
     This is THE JavaScript major mode.

     Let's install it and use it for *.js files.
     #+BEGIN_SRC emacs-lisp
       (use-package js2-mode
         :mode ("\\.js\\'")
         :init
         (setq js-indent-level 2))
     #+END_SRC
**** =xref2-js=
     From [[https://github.com/NicolasPetton/xref-js2][here]].\\
     This package provide a =xref= backend to easily jump to definitions in js
     files. It uses =ag=

     #+BEGIN_SRC emacs-lisp
       ;; (use-package xref-js2
       ;;   :bind (
       ;;          ;; Unbind M-. from js-mode-map, conflict with xref
       ;;          :map js-mode-map
       ;;          ("M-." . nil))
       ;;   ;; Add xref-js2 backend to xref-backends in js2-mode
       ;;   :hook (js2-mode . (lambda ()
       ;;                       (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))
     #+END_SRC
**** =js2-refactor=
     This package (see [[https://github.com/magnars/js2-refactor.el][here]]) adds cool refactoring features !

     Map it to =C-c C-r= and enabled it automatically for js files.
     #+BEGIN_SRC emacs-lisp
       (use-package js2-refactor
         :hook (js2-mode . js2-refactor-mode)
         :config
         (js2r-add-keybindings-with-prefix "C-c C-r"))
     #+END_SRC
**** =company-tern=
     See [[https://github.com/proofit404/company-tern][here]].\\
     A =company= backend based on [[https://github.com/ternjs/tern][tern]], to have a nice auto-completion for
     JavaScript.

     It requires to have =tern= installed on the system. Let's do it globally by
     running the following command :
     #+BEGIN_SRC sh
       npm install -g tern
     #+END_SRC
     TODO: I need to find a way to make my =NVM= lazy-loading works with
     Emacs.\\
     For now, I disabled it and source the =nvm.sh= script by default.

     You need to have a =~/.tern-config= and/or a =.tern-projectile= file at the
     root of your project. See [[http://ternjs.net/doc/manual.html][here]] for the documentation.

     =tern= doesn't do live-reload of =.tern-project= files, you need to restart
     the server to do so.\\
     Since there's no built-in function in =tern.el= to kill or restart the
     server gracefully, I wrote my own function (inspired by [[https://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring][this]]) to kill all
     the =tern= server processes.\\
     That way, =company-tern= will launch a new server with the up-to-date
     configuration the next time I call company.

     That's kind of hackish, but it's the simplest solution I found, since I'm
     very bad at elisp.
     #+BEGIN_SRC emacs-lisp
       ;; (defun lrn/kill-tern-servers ()
       ;;   "Kill all the Tern server processes"
       ;;   (interactive)
       ;;   (dolist (process (process-list))
       ;;     (let ((pname (process-name process)))
       ;;       (if (string-match "Tern" pname)
       ;;           (kill-process pname))))
       ;;   (message "All the Tern server processes were killed."))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       ;; (use-package company-tern
       ;;   :after company
       ;;   :hook (js2-mode . (lambda ()
       ;;                       (add-to-list 'company-backends 'company-tern)
       ;;                       (tern-mode)))
       ;;   :bind (:map tern-mode-keymap
       ;;          ("M-." . nil)
       ;;          ("M-," . nil)
       ;;          :map js2-mode-map
       ;;          ("C-c k" . lrn/kill-tern-servers)))
     #+END_SRC

**** =tide=
     =tide= (see [[https://github.com/ananthakumaran/tide][here]]) is another JavaScript/TypeScript IDE, built on
     =tsserver=.\\
     It seems to offer a lot a cool features, including completion, doc,
     refactoring, linting, jump to definition and stuff.

     Let's try it to see if it can supplant =tern=, =xref2-js=, =js2-refactor=...
     #+BEGIN_SRC emacs-lisp
       (defun lrn/tide-setup-hook ()
         (company-mode t)
         (flycheck-mode t)
         (tide-setup)
         (tide-hl-identifier-mode)
         (add-hook 'before-save-hook 'tide-format-before-save t 'make-it-local))

       (use-package tide
         :hook ((js2-mode . lrn/tide-setup-hook)
                (typescript-mode . lrn/tide-setup-hook)))
     #+END_SRC

     =tide=, needs you to have at least on =jsconfig.json= or =tsconfig.json= at
     the root of your project (since it works with =tsserver=, just like
     VSCode). See [[https://code.visualstudio.com/docs/languages/jsconfig][here]] for the syntax.

     Conclusion: It does a wonderful job, giving me all the features of the 2
     up-mentioned packages in one.\\
     The refactoring is very light compared to =js2-refactor=, so I'll keep it.\\
     However, it doesn't come with a keymap. I need to map a lot of stuff myself.

     It also seems that =tide= doesn't work for a javascript buffer not
     associated to a file... Need to find more info about that.
**** Stuff to try !
     [[http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html#install_emacs_packages][ESLint]] - Tide is suppose to do linting, but I don't know if it's JSHint
     like js-mode... EDIT: eslint is shipped with =js2-mode=, however, I'll read
     the blog post.
     [[https://github.com/NicolasPetton/Indium][Indium]] or [[https://github.com/skeeto/skewer-mode][Skewer]] - Both are environment to do live dev. Apparently Indium
     can do more (evaluating JS, scratch buffer, REPL, debugging). I never
     really used this kind of features, but it could be fun to try.
*** Go
    Check [[http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/][this]], [[https://johnsogg.github.io/emacs-golang][this]], [[https://www.reddit.com/r/emacs/comments/5t6rnt/recommended_configpackages_for_golang/][this]], [[http://yousefourabi.com/blog/2014/05/emacs-for-go/][this]] and [[http://dominik.honnef.co/posts/2013/03/writing_go_in_emacs/][that]].

    Almost all of the following packages requires the golang tools.
    They can all be installed at once by running:
    #+BEGIN_SRC sh
      go get -u golang.org/x/tools/cmd/...
    #+END_SRC

**** =go-mode=
     From [[https://github.com/dominikh/go-mode.el][here]].

     A major-mode for Golang ! Provides a lot of features, such as =gofmt=,
     =godef= or =godoc= integration.

     #+BEGIN_SRC emacs-lisp
       (use-package go-mode
         :mode ("\\.go\\'")
         :hook ((go-mode . (lambda () (add-hook 'before-save-hook 'gofmt-before-save nil 'local))))
         :bind (
                :map go-mode-map
                ("M-." . godef-jump)
                ("M-," . pop-tag-mark)
                ("C-c C-r" . go-remove-unused-imports)
                ("C-c g" . gofmt)
                ("C-c C-k" . godoc)
                ("C-c k" . godoc-at-point)))
     #+END_SRC

**** =go-guru=
     From [[https://github.com/dominikh/go-mode.el][here]] too.\\
     =go-guru= is a great tool that provides code-analysis features. (Find the
     implementations, the callees, the callers etc...)

     It requires the =guru= binary to work. It should already be installed, but
     just in case:
     #+BEGIN_SRC sh
       go get -u golang.org/x/tools/cmd/guru
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (use-package go-guru
         :hook (go-mode . go-guru-hl-identifier-mode)
         :bind (
                ;; I need to explicitly map it, since I already use C-c C-o system-wide for org-open-at-point-global
                :map go-mode-map
                ("C-c C-o" . go-guru-map)))
     #+END_SRC

**** =goimports=
     From [[https://godoc.org/golang.org/x/tools/cmd/goimports][here]].\\
     This golang command manages imports for you !

     You need to install the =goimports= binary first.
     #+BEGIN_SRC sh
       go get -u golang.org/x/tools/cmd/goimports
     #+END_SRC

     Then set it as =gofmt-command=
     #+BEGIN_SRC emacs-lisp
       (setq gofmt-command "goimports")
     #+END_SRC

**** =company-go=
     From [[https://github.com/nsf/gocode][here]]. Doc for =company= [[https://github.com/nsf/gocode/tree/master/emacs-company][here]].

     An autocompletion backend for golang that integrates with =company=\\
     It requires =godoc= binary to work. Install it with:
     #+BEGIN_SRC sh
       go get -u github.com/nsf/gocode
     #+END_SRC

     TODO: Apparently, it's deprecated... but it works great for now.
     #+BEGIN_SRC emacs-lisp
       (use-package company-go
         :hook (company-mode . (lambda () (add-to-list 'company-backends 'company-go))))
     #+END_SRC

**** =go-eldoc=
     From [[https://github.com/syohex/emacs-go-eldoc][here]].

     This package provided =eldoc= integration for golang. Just like
     =company-go=, it requires =godoc= in order to work.
     #+BEGIN_SRC emacs-lisp
       (use-package go-eldoc
         :hook (go-mode . (lambda () (go-eldoc-setup))))
     #+END_SRC
**** =goflymake=
     From [[https://github.com/dougm/goflymake][here]].

     A package that provide a golang checker for =flycheck=.
     It requires the =goflymake= binary to work. Install it with:
     #+BEGIN_SRC sh
       go get -u github.com/dougm/goflymake
     #+END_SRC

     It's not on MELPA, so I get it as a submodule.
     #+BEGIN_SRC emacs-lisp
       (add-to-list 'load-path (concat user-emacs-directory "config/goflymake"))
       (require 'go-flycheck)
     #+END_SRC

*** PHP
    Coming soon...
    TODO: Check [[https://www.philnewton.net/guides/emacs-as-a-php-editor/][this]], [[http://irreal.org/blog/?p=5499][this]], [[http://www.blogbyben.com/2016/08/emacs-php-modern-and-far-more-complete.html][this]], [[https://www.drupal.org/docs/develop/development-tools/emacs][this]] and [[https://github.com/emacs-php/php-suite][that]].
** Shell
   I use my terminal A LOT. So if I can use it directly in Emacs and so some
   cool tricks...

*** =multi-term=
    I'm not sure why I chose =multi-term=, but it looks like a popular option !
    Thanks @[[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org#terminal][HRS]]

    Let's bind it to =C-t= (override =-pop-tag-mark=)
    #+BEGIN_SRC emacs-lisp
      (use-package multi-term
        :bind (
               :map lrn/custom-map
               ("t" . multi-term)))
    #+END_SRC

*** =shell-command=
    By default, =shell-command= is bound on =M-!=. It may be fine for the rest
    of the world, but for me, using Chunkwm on OSX, I use this binding to change
    workspace...

    Let's rebind =shell-command= on =C-S-t=
    #+BEGIN_SRC emacs-lisp
      (define-key evil-normal-state-map (kbd "C-S-t") 'shell-command)
    #+END_SRC
** Docker
   See [[http://manuel-uberti.github.io/emacs/2017/10/19/docker/][here]].\\
   Praise the blue whale \o/

   TODO: Check [[https://github.com/Silex/docker.el][this]] package.
*** =dockerfile-mode=
    See [[https://github.com/spotify/dockerfile-mode][here]].\\
    This package adds syntax highlighting for =Dockerfile=s and =docker build= feature to Emacs.
    What's not to love ?

    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode ("Dockerfile\\'"))
    #+END_SRC

*** =docker-compose-mode=
    See [[https://github.com/meqif/docker-compose-mode][here]].\\
    This packages adds completion for =docker-compose.yml= files.
    Simple, basique !

    #+BEGIN_SRC emacs-lisp
      (use-package docker-compose-mode)
    #+END_SRC
* Miscellaneous
** =speed-type=
   From [[https://github.com/hagleitn/speed-type][here]].

   Considering the time I spent on [[https://10fastfingers.com/][10FastFingers]], it's obvious that I need a
   similar mode in Emacs :D And there's one <3

   Run it with =M-x speed-type-text=
   #+BEGIN_SRC emacs-lisp
     (use-package speed-type)
   #+END_SRC
** =sx=
   From [[https://github.com/vermiculus/sx.el][here]].

   What ? A mode to browse Stack Exchange websites from within Emacs ? REALLY ?

   TODO: I want to switch to =evil-insert-state= when I enter
   =sx-question-list-mode=,  but the hook doesn't seems to work =/
   #+BEGIN_SRC emacs-lisp
     (use-package sx
       :init
       (setq sx-default-site 'stackoverflow)
       ;; This is my workaround to replicate the sx-default-site feature using Ivy
       (add-to-list 'ivy-initial-inputs-alist '(sx-search . "^stackoverflow"))
       (add-to-list 'ivy-initial-inputs-alist '(sx-tab-all-questions . "^stackoverflow"))
       :config
       (bind-keys :prefix "C-c s"
                  :prefix-map lrn/sx-map
                  :prefix-docstring "Global keymap for SX."
                  ("q" . sx-tab-all-questions)
                  ("i" . sx-inbox)
                  ("o" . sx-open-link)
                  ("u" . sx-tab-unanswered-my-tags)
                  ("a" . sx-ask)
                  ("s" . sx-search)))
   #+END_SRC
