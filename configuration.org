#+TITLE: My wonderful Emacs configuration
#+AUTHOR: LeReverandNox
#+PROPERTY: header-args    :results silent

* Use sensible-defaults.el
  Use [[https://github.com/hrs/sensible-defaults.el][sensible-defaults.el]] by [[https://github.com/hrs/sensible-defaults.el][@HRS]] to setup basic and usefull stuff without
  recoding it myself :)

  #+BEGIN_SRC emacs-lisp
    (load (concat user-emacs-directory "config/sensible-defaults/sensible-defaults.el"))

    (sensible-defaults/shorten-yes-or-no)
    (sensible-defaults/delete-trailing-whitespace)
    (sensible-defaults/show-matching-parens)
    (sensible-defaults/make-scripts-executable)
    (sensible-defaults/overwrite-selected-text)
    (sensible-defaults/ensure-that-files-end-with-newline)
    (sensible-defaults/confirm-closing-emacs)
    (sensible-defaults/quiet-startup)
    (sensible-defaults/always-highlight-code)
    (sensible-defaults/refresh-buffers-when-files-change)
    (sensible-defaults/bind-commenting-and-uncommenting)
    (sensible-defaults/set-default-line-length-to 80)
    (sensible-defaults/flash-screen-instead-of-ringing-bell)
  #+END_SRC

* Package management (=package=, =use-package= and =auto-compile=)
** Setup =package= and it' s sources...
*** Setup
    Note to myself: I need to try [[https://emacs.stackexchange.com/a/2989][that]] sometime, to achieve source
    prioritization. For now, let's disable =melpa-stable=
    #+BEGIN_SRC emacs-lisp
      (require 'package)
      (setq package-enable-at-startup nil)

      (unless (assoc-default "org" package-archives)
        (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/")))
      (unless (assoc-default "melpa" package-archives)
        (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/")))
      ;; (unless (assoc-default "melpa-stable" package-archives)
      ;; (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/")))

      (when (< emacs-major-version 27)
        (package-initialize))
    #+END_SRC

    Don't forget to run =M-x package-refresh-contents= to reload the package list
    when you add a new source or if you can't find a package.

*** Upgrade
    From [[https://emacs.stackexchange.com/a/31874][this]] post.

    To upgrade packages, run =M-x list-packages=, hit =U= (=package-menu-mark-upgrades=) to mark available
    upgrades, then =x= (=package-menu-execute=) to install them and finally =y= to confirm.
    Then run =M-x package-autoremove= to remove old versions.\\
    Apparently, it can be done via another package... but for now I prefer to do
    it manually.

    Here's 2 cool functions from the StackExchange post, to save some time in
    the package menu.\\
    The first one allows to find marked packages and the second one allows to
    filter by status. Respectively bind to =a= and =s=

    #+BEGIN_SRC emacs-lisp
      (defun package-menu-find-marks ()
        "Find packages marked for action in *Packages*."
        (interactive)
        (occur "^[A-Z]"))

      ;; Only in Emacs 25.1+
      (defun package-menu-filter-by-status (status)
        "Filter the *Packages* buffer by status."
        (interactive
         (list (completing-read
                "Status: " '("available" "new" "installed" "dependency" "obsolete"))))
        (package-menu-filter (concat "status:" status)))

      (with-eval-after-load 'bind-key
        (bind-key "s" 'package-menu-filter-by-status package-menu-mode-map)
        (bind-key "a" 'package-menu-find-marks package-menu-mode-map))

      ;; Disable evil for package-menu-mode
      (add-hook 'package-menu-mode-hook (lambda ()
                                          (evil-set-initial-state 'package-menu-mode 'emacs)))
    #+END_SRC

** then, setup =use-package=, our beloved package-manager...
   See [[https://github.com/jwiegley/use-package][here]].
   #+BEGIN_SRC emacs-lisp
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))
   #+END_SRC

   Always ensure packages are installed, to avoid repetition

   #+BEGIN_SRC emacs-lisp
     (setq use-package-always-ensure t)
   #+END_SRC

   Require additional modules to use cool features of =use-package=

   #+BEGIN_SRC emacs-lisp
     (use-package diminish)
     (require 'bind-key)  ;; if you use any :bind variant
   #+END_SRC

** and finally, use =auto-compile= to always compile packages and use the latest version.
   From [[https://github.com/emacscollective/auto-compile][here]].\\
   #+BEGIN_SRC emacs-lisp
     (use-package auto-compile
       :init
       ;; Prevent outdated byte-code loading
       (setq load-prefer-newer t)
       :config
       (progn
         ;; Auto-compile before loading if byte-code is outdated
         (auto-compile-on-load-mode)))
   #+END_SRC
** =try=
   From [[https://github.com/larstvei/Try][here]].\\
   This package allow to test other package without installing them. Looks cool,
   let's give it a try !

   #+BEGIN_SRC emacs-lisp
     (use-package try)
   #+END_SRC
* Dvorak
  Since I switch from Qwerty to Dvorak, =C-x= has become a real pain to type...
  According to the [[https://www.emacswiki.org/emacs/DvorakKeyboard#toc1][EmacsWiki]], =C-z= might be a good alternative, since it's not
  a usefull binding, and it allow to have it on the right hand along with =f=,
  =s=, =w=, etc.\\
  Let's give it a shot !

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-z") ctl-x-map)
  #+END_SRC
* Custom map
  After some research, I found [[https://karl-voit.at/2018/07/08/emacs-key-bindings/][this]] interesting article about how to deal with
  custom keybindings in order to avoid messing with the default Emacs and
  package bindings.

  Idealy, I wish I could have used only =hydra= to achieve this, but for now,
  you can't add heads to an exhisting =hydra=, you need to declare all at
  once, in a same spot...\\
  I can't do that, I want to keep my config 'orgagnized' by logical section, each one
  having it's own set of related bindings.

  So I decided to create my personal map here, and then, add as many =hydra= I
  need in it.

  I also didn't knew what keybinding to choose for my map. After a bit of
  research ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Key-Binding-Conventions.html][this]] ressource was really helpful) and some trial and error, =C-c c=
  seems like a decent choice.
  It didn't seems to be used (for now) by any of the packages that I use.


  #+BEGIN_SRC emacs-lisp
    (bind-keys :prefix "C-c c"
               :prefix-map lrn/custom-map
               :prefix-docstring "My very own custom map to hold a lotta stuff")
  #+END_SRC

* =Hydra=
   From [[https://github.com/abo-abo/hydra][here]].\\
   To read: [[https://matutine.gitlab.io/2015/03/11/les-hydres-vont-enchanter-votre-exp-C3-A9rience-avec-emacs.html][here]], [[https://oremacs.com/2015/01/20/introducing-hydra/][here]], [[https://cestlaz.github.io/posts/using-emacs-30-elfeed-2/][here]], [[https://writequit.org/denver-emacs/presentations/2017-06-20-hydra.html][here]], [[https://www.wisdomandwonder.com/article/10748/emacsorg-mode-abo-abos-hydra-makes-you-a-lightweight-literate-programmer-hyper-boosting-your-productivity-with-about-ten-of-minutes-effort-for-learning-it][here]]

   I need to load =hydra= pretty early in the file, since I use it for =evil-mc=
   #+BEGIN_SRC emacs-lisp
     (use-package hydra)
   #+END_SRC
* Beyond good and =Evil=
  I love Emacs, but I can't live without Vim bindings...
  Ever since I watched [[https://www.youtube.com/watch?v=JWD1Fpdd4Pc][this]] video, I knew it was only a matter of time until I
  switch to Emacs

  So without further ado, ladies and gentlemen : EVIL !
** =evil=
   From [[https://github.com/emacs-evil/evil][here]].\\

   I'd want to be able to return to Normal state by pressing =C-g=, I think it's
   more convenient than =Esc=. (See [[https://emacs.stackexchange.com/a/13770][here]].)\\
   Be careful, the minibuffers don't use =keyboard-quit= to be closed, but
   =abort-recursive-edit=. It should do the trick.

   Maybe it broke the behavior of =C-g= for some other action, I dond't know
   yet. We'll see.
   #+BEGIN_SRC emacs-lisp
     (defun evil-keyboard-quit ()
       "Keyboard quit and force normal state."
       (interactive)
       (and evil-mode (evil-force-normal-state))
       (if (active-minibuffer-window)
           (minibuffer-keyboard-quit)
         (keyboard-quit)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package evil
       :bind (
              :map evil-normal-state-map
              ;; I need to unbind M-. (evil-repeat-pop-next) to make goto-definition work when programming
              ("M-." . nil)
              ;; Unbind C-t (pop-tar-mark), I use M-, (and it overrides transpose-chars)
              ("C-t" . nil)
              ;; Unbind Z Z and ZQ, I don't use them to exit Emacs
              ("Z Z" . nil)
              ("Z Q" . nil)
              :map evil-motion-state-map
              ;; Bind (evil-jump-forward) to C-S-o
              ("C-S-o" . evil-jump-forward)
              ;; Unbind C-z, since it's my C-x alternative for Dvorak
              ("C-z" . nil)
              ;; Return to Normal state with C-g
              ("C-g" . evil-keyboard-quit)
              :map evil-insert-state-map
              ;; Return to Normal state with C-g
              ("C-g" . evil-keyboard-quit)
              ;; Unbind evil-state-mode from Insert state, cause too much trouble since I use C-z as C-x
              ("C-z" . nil)
              :map evil-operator-state-map
              ;; Return to Normal state with C-g
              ("C-g" . evil-keyboard-quit)
              :map evil-replace-state-map
              ;; Return to Normal state with C-g
              ("C-g" . evil-keyboard-quit)
              :map evil-visual-state-map
              ;; Return to Normal state with C-g
              ("C-g" . evil-keyboard-quit))
       :init
       ;; Don't expand the abbrev when going back to Normal state
       (setq evil-want-abbrev-expand-on-insert-exit nil)
       ;; Shift lines by 2 spaces
       (setq-default evil-shift-width 2)
       ;; Enable Evil bindings in the minibuffer
       (setq evil-want-minibuffer t)
       ;; Don't use regex during search
       (setq evil-regexp-search nil)
       ;; Use much more smaller step for undo
       (setq evil-want-fine-undo t)
       ;; Disable keybindings, for evil-collection
       (setq evil-want-keybinding nil)
       ;; I don't want to bind C-i (evil-jump-forward), since C-i = TAB and vice-versa... TAB is TAB !
       (setq evil-want-C-i-jump nil)
       :config
       (evil-mode t))
   #+END_SRC

   I want to be able to toggle =evil-emacs-state= easily. I don't use it often,
   but it can be helpful sometimes. Let's bind a function to toggle it in my
   custom map.
   #+BEGIN_SRC emacs-lisp
     (defun lrn/toggle-evil-emacs-state ()
       "Toggle evil-emacs-state"
       (interactive)
       (if (equal evil-state 'emacs)
           (evil-force-normal-state)
         (evil-emacs-state)))

     (bind-key "z" 'lrn/toggle-evil-emacs-state lrn/custom-map)
   #+END_SRC
** =evil-collection=
   From [[https://github.com/emacs-evil/evil-collection][here]].\\
   =evil-collection= adds a shitload of keybindings for a shitload of modes.
   I don't know if it worth it, but I'm gonna give it a shot.
   #+BEGIN_SRC emacs-lisp
     (use-package evil-collection
       :after evil
       :config
       (progn
         ;; Disable neotree bindings, I'm already happy with mine
         (setq evil-collection-mode-list (remove 'neotree evil-collection-mode-list))
         ;; Disable outline bindings, conflict with TAB (org-cycle)
         (setq evil-collection-mode-list (remove 'outline evil-collection-mode-list))
         ;; Disable package-menu bindings, I don't use evil for this mode
         (setq evil-collection-mode-list (remove 'package-menu evil-collection-mode-list))
         (evil-collection-init)))
   #+END_SRC

** =evil-surround=
   From [[https://github.com/emacs-evil/evil-surround][here]].\\
   Let's also add =evil-surround= to have surrounding, just like in Vim ! Hu-uh !
   #+BEGIN_SRC emacs-lisp
     (use-package evil-surround
       :config
       (global-evil-surround-mode t))
   #+END_SRC

** =evil-mc=
   From [[https://github.com/gabesoft/evil-mc][here]].\\
   And =evil-mc=, to have multiple-cursors... again, just like in Vim !
   #+BEGIN_SRC emacs-lisp
     (use-package evil-mc
       :diminish evil-mc-mode
       :config
       (global-evil-mc-mode 1))
   #+END_SRC

   Let's make an =hydra= to bind =evil-mc= commands on my custom map
   #+BEGIN_SRC emacs-lisp
     (defhydra lrn/hydra-evil-mc (
                                  :color pink
                                  :hint nil)
       "
               ^Up^                        ^Down^                     ^Other^
     -----------------------------------------------------------------------------------
     [_k_]   Make & prev line    [_j_]   Make & next line    [_<mouse-1>_] Make at click
     [_p_]   Make & prev match   [_n_]   Make & next match   [_a_]         Make all
     [_C-p_] Make & prev curs.   [_C-n_] Make & next curs.   [_u_]         Undo all
     [_P_]   Skip & prev match   [_N_]   Skip & next match   [_q_]         Quit
     [_C-P_] Skip & prev curs.   [_C-N_] Skip & prev curs.
     "
       ("k" evil-mc-make-cursor-move-prev-line)
       ("p" evil-mc-make-and-goto-prev-match)
       ("C-p" evil-mc-make-and-goto-prev-cursor)
       ("P" evil-mc-skip-and-goto-prev-match)
       ("C-P" evil-mc-skip-and-goto-prev-cursor)
       ("j" evil-mc-make-cursor-move-next-line)
       ("n" evil-mc-make-and-goto-next-match)
       ("C-n" evil-mc-make-and-goto-next-cursor)
       ("N" evil-mc-skip-and-goto-next-match)
       ("C-N" evil-mc-skip-and-goto-next-cursor)
       ("<mouse-1>" evil-mc-toggle-cursor-on-click)
       ("a" evil-mc-make-all-cursors :color blue)
       ("u" evil-mc-undo-all-cursors :color blue)
       ("<down-mouse-1>" ignore :hint nil)
       ("<drag-mouse-1>" ignore :hint nil)
       ("q" nil)
       ("C-g" nil))
     (bind-key "m" 'lrn/hydra-evil-mc/body lrn/custom-map)
   #+END_SRC
* UI / UX
** Tweak UI
   Hide menu / tool / scroll bars, for I don't use them
   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC

   Always show line-numbers in margin. Can't live without it !
   #+BEGIN_SRC emacs-lisp
     (global-display-line-numbers-mode t)
   #+END_SRC

   Make the frame title a bit more meaningful by displaying the current project
   name instead of the current filename
   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format '((:eval (projectile-project-name))))
   #+END_SRC
** Theme
   Set the =themes= directory
   #+BEGIN_SRC emacs-lisp
     (setq custom-theme-directory
           (concat user-emacs-directory "themes"))
   #+END_SRC

   +Load my (current) favorite theme, earthsong+
   #+BEGIN_SRC emacs-lisp
     ;; (load-theme 'earthsong t)
   #+END_SRC

   Okay, let's try one of my other favorite theme, One Dark from Atom.
   #+BEGIN_SRC emacs-lisp
     ;; (use-package atom-one-dark-theme
     ;;   :config
     ;;   (progn
     ;;     (load-theme 'atom-one-dark t)))
   #+END_SRC

   This theme seems lovely, let's give it a shot.
   #+BEGIN_SRC emacs-lisp
     (use-package cherry-blossom-theme
       :config
       (progn
         (load-theme 'cherry-blossom t)
         (set-face-attribute 'default nil
                             :background "#1a1a1a")))
   #+END_SRC

   I love some transparency. Let's make it a bit transparent when active, and a
   bit more transparent when inactive
   #+BEGIN_SRC emacs-lisp
     ;;(set-frame-parameter (selected-frame) 'alpha '(<active> . <inactive>))
     (set-frame-parameter (selected-frame) 'alpha '(95 . 80))
     (add-to-list 'default-frame-alist '(alpha . (95 . 80)))
   #+END_SRC

   I also like to have a more visible =verbatim= face in =org-mode=.
   Not quite sur about the color, but it will do the trick.
   #+BEGIN_SRC emacs-lisp
     (set-face-attribute 'org-verbatim nil
                         :foreground (face-attribute 'warning :foreground))
   #+END_SRC

   Let's also allow customization of =font-lock-maximum-decoration= per mode, so
   I can choose to use or not the additional decoration. (For example, the
   decoration provided to =dired-mode= by =dired+= is ugly...)
   #+BEGIN_SRC emacs-lisp
     (setq font-lock-maximum-decoration '((t . t)))
   #+END_SRC
** Font
   Thanks again to @HRS for those really helpful functions !

*** Setup
    Let's set =Office Code Pro= as the default font
    #+BEGIN_SRC emacs-lisp
      (setq hrs/default-font "Office Code Pro")
    #+END_SRC

    With a default size of 12
    #+BEGIN_SRC emacs-lisp
      (setq hrs/default-font-size 12)
    #+END_SRC

*** Resizing
    Really cool fonctions :)
    #+BEGIN_SRC emacs-lisp
      (defun hrs/font-code ()
        "Return a string representing the current font (like \"Inconsolata-14\")."
        (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

      (defun hrs/set-font-size ()
        "Set the font to `hrs/default-font' at `hrs/current-font-size'.
         Set that for the current frame, and also make it the default for
         other, future frames."
        (let ((font-code (hrs/font-code)))
          (add-to-list 'default-frame-alist (cons 'font font-code))
          (set-frame-font font-code)))

      (defun hrs/reset-font-size ()
        "Change font size back to `hrs/default-font-size'."
        (interactive)
        (setq hrs/current-font-size hrs/default-font-size)
        (hrs/set-font-size))

      (defun hrs/increase-font-size ()
        "Increase current font size by a factor of `hrs/font-change-increment'."
        (interactive)
        (setq hrs/current-font-size
              (ceiling (* hrs/current-font-size hrs/font-change-increment)))
        (hrs/set-font-size))

      (defun hrs/decrease-font-size ()
        "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
        (interactive)
        (setq hrs/current-font-size
              (max 1
                   (floor (/ hrs/current-font-size hrs/font-change-increment))))
        (hrs/set-font-size))
    #+END_SRC

    Increment font by 0.5%
    #+BEGIN_SRC emacs-lisp
      (setq hrs/font-change-increment 1.05)
    #+END_SRC

    Let's create an =hydra= to resize the font and bind it on my custom map.
    #+BEGIN_SRC emacs-lisp
      (defhydra lrn/hydra-font-size ()
        "Resize the font"
        ("=" hrs/increase-font-size "bigger")
        ("-" hrs/decrease-font-size "smaller")
        ("0" hrs/reset-font-size "reset")
        ("q" nil "quit"))
      (bind-key "=" 'lrn/hydra-font-size/body lrn/custom-map)
    #+END_SRC

    Reset the font size at startup
    #+BEGIN_SRC emacs-lisp
      (hrs/reset-font-size)
    #+END_SRC
** Modeline
*** =powerline=
    From [[https://www.google.com/search?client=firefox-b-ab&q=emacs+powerline][here]].\\
    I love Vim's powerline, so when I heard there's an Emacs version...

    Here's a fork of the =powerline-evil-center-color-theme= (from [[https://github.com/raugturi/powerline-evil][here]]) that
    display the =mode-line-misc-info= variable. I need it for =eyebrowse= to
    display it's workspaces. (see [[https://github.com/milkypostman/powerline/issues/140][this]] issue)\\
    I don't really know what I'm doing, I just tried to
    understand roughly how a =mode-line-format= works and hacked my way through.
    #+BEGIN_SRC emacs-lisp
      (use-package powerline-evil
        :config
        (defun lrn/powerline-evil-center-color-theme ()
          "A custom Powerline's center-evil them with the evil state in color and the
        mode-line-misc-info displayed."
          (interactive)
          (setq-default mode-line-format
                        '("%e"
                          (:eval
                           (let* ((active (powerline-selected-window-active))
                                  (mode-line (if active 'mode-line 'mode-line-inactive))
                                  (face1 (if active 'powerline-active1 'powerline-inactive1))
                                  (face2 (if active 'powerline-active2 'powerline-inactive2))
                                  (separator-left (intern (format "powerline-%s-%s"
                                                                  (powerline-current-separator)
                                                                  (car powerline-default-separator-dir))))
                                  (separator-right (intern (format "powerline-%s-%s"
                                                                   (powerline-current-separator)
                                                                   (cdr powerline-default-separator-dir))))
                                  (lhs (list (powerline-raw "%*" nil 'l)
                                             (powerline-buffer-size nil 'l)
                                             (powerline-buffer-id nil 'l)
                                             (powerline-raw " ")
                                             (funcall separator-left mode-line face1)
                                             (powerline-narrow face1 'l)
                                             (powerline-vc face1)))
                                  (rhs (list (powerline-raw global-mode-string face1 'r)
                                             (powerline-raw "%4l" face1 'r)
                                             (powerline-raw ":" face1)
                                             (powerline-raw "%3c" face1 'r)
                                             (funcall separator-right face1 mode-line)
                                             (powerline-raw " ")
                                             (powerline-raw "%6p" nil 'r)
                                             (powerline-hud face2 face1)
                                             (powerline-raw mode-line-misc-info face2 'r)))
                                  (center (append (list (powerline-raw " " face1)
                                                        (funcall separator-left face1 face2)
                                                        (when (boundp 'erc-modified-channels-object)
                                                          (powerline-raw erc-modified-channels-object face2 'l))
                                                        (powerline-major-mode face2 'l)
                                                        (powerline-process face2)
                                                        (powerline-raw " " face2))
                                                  (let ((evil-face (powerline-evil-face)))
                                                    (if (split-string (format-mode-line minor-mode-alist))
                                                        (append (if evil-mode
                                                                    (list (funcall separator-right face2 evil-face)
                                                                          (powerline-raw (powerline-evil-tag) evil-face 'l)
                                                                          (powerline-raw " " evil-face)
                                                                          (funcall separator-left evil-face face2)))
                                                                (list (powerline-minor-modes face2 'l)
                                                                      (powerline-raw " " face2)
                                                                      (funcall separator-right face2 face1)))
                                                      (list (powerline-raw (powerline-evil-tag) evil-face)
                                                            (funcall separator-right evil-face face1)))))))
                             (concat (powerline-render lhs)
                                     (powerline-fill-center face1 (/ (powerline-width center) 2.0))
                                     (powerline-render center)
                                     (powerline-fill face1 (powerline-width rhs))
                                     (powerline-render rhs))))))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package powerline
        :after powerline-evil
        :config
        (lrn/powerline-evil-center-color-theme))
    #+END_SRC
*** Clock
    It's sometime more convenient to check the time directly in Emacs, instead of
    looking at the OS status bar. Especially in fullscreen mode.\\
    I not enabling it for now, for I spend most of my time on MacOS. But I use it
    for sure on Linux.

    #+BEGIN_SRC emacs-lisp
      ;; (display-time-mode)

    #+END_SRC

    Let's also customize the time format. See [[https://help.gnome.org/users/gthumb/stable/gthumb-date-formats.html.en][here]] for reference :)
    #+BEGIN_SRC emacs-lisp
      (setq display-time-format "%H:%M:%S")
    #+END_SRC
*** =diminish=
    From [[https://github.com/myrjola/diminish.el][here]].\\
    The =modeline= is often waaaay to crowded, when a lot of modes are enabled.
    Hopefully, there's =dimisish= ! It allows you to rename every minor/major
    modes to save space.

    =diminish= is also supported directly by =use-package= with the =:dimish= option.
    I try to use it whenever I can, but for some default modes, I still need to
    write it here.

    First, two macros to make things easier
    #+BEGIN_SRC emacs-lisp
      (defmacro diminish-minor-mode (filename mode &optional abbrev)
        `(eval-after-load (symbol-name ,filename)
           '(diminish ,mode ,abbrev)))

      (defmacro diminish-major-mode (mode-hook abbrev)
        `(add-hook ,mode-hook
                   (lambda () (setq mode-name ,abbrev))))
    #+END_SRC

    And now =diminish=  itself.
    #+BEGIN_SRC emacs-lisp
      (use-package diminish
        :config
        (diminish-major-mode 'emacs-lisp-mode-hook "el")
        (diminish-major-mode 'python-mode-hook "Py")
        (diminish-major-mode 'js-mode-hook "JS")
        (diminish-major-mode 'sh-mode-hook "Sh")
        (diminish-minor-mode 'abbrev 'abbrev-mode))
    #+END_SRC
** Icons
   From [[https://github.com/domtronn/all-the-icons.el][here]].\\
   Because it's always nice to have cool icons instead of plain text
   #+BEGIN_SRC emacs-lisp
     (use-package all-the-icons)
   #+END_SRC
** File Explorer
*** =neotree=
    From [[https://www.google.com/search?client=firefox-b-ab&q=emacs+neotree][here]].\\
    Similar to Vim's Nerdtree, such a cool package to browse the filesystem in a
    conveniant sidebar <3

    Thanks [[https://github.com/jaypei/emacs-neotree/issues/293][@stereoproxy]] for this function that allows me to close the parent
    directory of a node easily !
    #+BEGIN_SRC emacs-lisp
      (defun my/neotree-close-parent ()
        "Close parent directory of current node."
        (interactive)
        (neotree-select-up-node)
        (let* ((btn-full-path (neo-buffer--get-filename-current-line))
               (path (if btn-full-path btn-full-path neo-buffer--start-node)))
          (when (file-name-directory path)
            (if (neo-buffer--expanded-node-p path) (neotree-enter)))))
    #+END_SRC

    Thanks to [[https://emacs.stackexchange.com/a/29500][@ideasman42]] for this function that will open =neotree= at the
    current =projectile= root, or the directory of the current buffer if not in a
    projet. I'll use it instead of =neotree-projectile-action=.
    #+BEGIN_SRC emacs-lisp
      (defun my/neotree-project-dir-toggle ()
        "Open NeoTree using the project root, using find-file-in-project,
      or the current buffer directory."
        (interactive)
        (let ((project-dir
               (ignore-errors
                 ;;; Pick one: projectile or find-file-in-project
                 ; (projectile-project-root)
                 (ffip-project-root)
                 ))
              (file-name (buffer-file-name))
              (neo-smart-open t))
          (if (and (fboundp 'neo-global--window-exists-p)
                   (neo-global--window-exists-p))
              (neotree-hide)
            (progn
              (neotree-show)
              (if project-dir
                  (neotree-dir project-dir))
              (if file-name
                  (neotree-find file-name))))))
    #+END_SRC

    Let's install =neotree= and set the bindings
    #+BEGIN_SRC emacs-lisp
      ;; (use-package neotree
      ;;   :bind (
      ;;          :map neotree-mode-map
      ;;          ;; Neotree doesn't respect the binding convention, it conflicts with my custom map.
      ;;          ("C-c c" . nil)
      ;;          ("s" . neotree-enter-horizontal-split)
      ;;          ("v" . neotree-enter-vertical-split)
      ;;          ("y" . neotree-copy-filepath-to-yank-ring)
      ;;          ("r" . neotree-refresh)
      ;;          ("C-c C-y" . neotree-copy-node)
      ;;          ("x" . my/neotree-close-parent)
      ;;          ("<tab>" . neotree-change-root)
      ;;          ("j" . neotree-next-line)
      ;;          ("k" . neotree-previous-line))
      ;;   :init
      ;;   (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
      ;;   (setq neo-window-fixed-size nil)
      ;;   ;; Switch to Emacs state when entering neotree-mode, no need for Evil there.
      ;;   (evil-set-initial-state 'neotree-mode 'emacs)
      ;;   (bind-key "n" 'neotree-show lrn/custom-map)
      ;;   (bind-key "N" 'my/neotree-project-dir-toggle lrn/custom-map))
    #+END_SRC

*** =treemacs=
    From [[https://github.com/Alexander-Miller/treemacs][here]].\\
    A replacement for =neotree=, more recent, with more features and a nicer UI.

    #+BEGIN_SRC emacs-lisp
      (use-package treemacs
        :defer t
        :config
        (progn
          (setq treemacs-collapse-dirs                 (if treemacs-python-executable 3 0)
                treemacs-deferred-git-apply-delay      0.5
                treemacs-display-in-side-window        t
                treemacs-eldoc-display                 t
                treemacs-file-event-delay              5000
                treemacs-file-follow-delay             0.2
                treemacs-follow-after-init             t
                treemacs-git-command-pipe              ""
                treemacs-goto-tag-strategy             'refetch-index
                treemacs-indentation                   2
                treemacs-indentation-string            " "
                treemacs-is-never-other-window         nil
                treemacs-max-git-entries               5000
                treemacs-missing-project-action        'ask
                treemacs-no-png-images                 nil
                treemacs-no-delete-other-windows       t
                treemacs-project-follow-cleanup        nil
                treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
                treemacs-position                      'left
                treemacs-recenter-distance             0.1
                treemacs-recenter-after-file-follow    nil
                treemacs-recenter-after-tag-follow     nil
                treemacs-recenter-after-project-jump   'always
                treemacs-recenter-after-project-expand 'on-distance
                treemacs-show-cursor                   nil
                treemacs-show-hidden-files             t
                treemacs-silent-filewatch              nil
                treemacs-silent-refresh                nil
                treemacs-sorting                       'alphabetic-desc
                treemacs-space-between-root-nodes      t
                treemacs-tag-follow-cleanup            t
                treemacs-tag-follow-delay              1.5
                treemacs-width                         35)

          ;; The default width and height of the icons is 22 pixels. If you are
          ;; using a Hi-DPI display, uncomment this to double the icon size.
          ;;(treemacs-resize-icons 44)

          (treemacs-follow-mode t)
          (treemacs-filewatch-mode t)
          (treemacs-fringe-indicator-mode t)
          (pcase (cons (not (null (executable-find "git")))
                       (not (null treemacs-python-executable)))
            (`(t . t)
             (treemacs-git-mode 'deferred))
            (`(t . _)
             (treemacs-git-mode 'simple))))
        :bind
        (:map global-map
              ("C-x t s"   . treemacs-select-window)
              ("C-x t 1"   . treemacs-delete-other-windows)
              ("C-x t t"   . treemacs)
              ("C-x t B"   . treemacs-bookmark)
              ("C-x t C-t" . treemacs-find-file)
              ("C-x t M-t" . treemacs-find-tag)))
    #+END_SRC

    Plug =treemacs= with =magit= so it can display better info regarding the git statuses
    #+BEGIN_SRC emacs-lisp
      (use-package treemacs-magit
        :after treemacs magit)
    #+END_SRC

    Add an additional =evil= map to =treemacs-mode=, to use =treemacs= without any conflict.
    #+BEGIN_SRC emacs-lisp
      (use-package treemacs-evil
        :after treemacs evil
        ;; Needed to force-load the package, since :bind implies a :defer
        :demand t
        :bind (
               ;; Remap C-g to its default value, since it's inherited from the motion-state-map...
               :map evil-treemacs-state-map
               ("C-g" . keyboard-quit)))
    #+END_SRC

    Easily add a =projectile= project to =treemacs=
    #+BEGIN_SRC emacs-lisp
      (use-package treemacs-projectile
        :after treemacs projectile
        :bind
        (:map global-map
              ("C-x t a" . treemacs-projectile)))
    #+END_SRC

    Use =treemacs= icons in =dired= buffers :D
    #+BEGIN_SRC emacs-lisp
      (use-package treemacs-icons-dired
        :after treemacs dired
        :config (treemacs-icons-dired-mode))
    #+END_SRC

** Completion
*** =helm= and friends
    From [[https://github.com/emacs-helm/helm][here]].\\
    See [[https://emacs-helm.github.io/helm/][here]] and [[http://tuhdo.github.io/helm-intro.html][here]].

    =helm= is just AWESOME ! It saves so much time, allowing to find anything in
    a few keystrokes.

    First, there is =helm= itself
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm
      ;;   :diminish helm-mode
      ;;   :bind  (
      ;;          ("M-x" . helm-M-x)
      ;;          ("C-x C-f" . helm-find-files)
      ;;          ("C-x y" . helm-show-kill-ring)
      ;;          ("C-x b" . helm-mini)
      ;;          ("C-X c o" . helm-occur)
      ;;          ("C-h a" . helm-apropos))
      ;;   :init
      ;;   (setq projectile-completion-system 'helm)
      ;;   (setq helm-apropos-fuzzy-match t)
      ;;   :config
      ;;   (helm-mode t))
    #+END_SRC

    then, there's =helm-descbinds=, for searching bindings
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm-descbinds
      ;;   :bind (
      ;;          ("C-h b" . helm-descbinds)
      ;;          ("C-h w" . helm-descbinds)))
    #+END_SRC

*** =ivy= and friends
    Ressources: [[https://sam217pa.github.io/2016/09/13/from-helm-to-ivy/][that]], [[https://adamsimpson.net/writing/helm-to-ivy][this]], [[http://blog.binchen.org/posts/hello-ivy-mode-bye-helm.html][that]], [[https://writequit.org/denver-emacs/presentations/2017-04-11-ivy.html][this]].

**** =ivy=
     From [[https://github.com/abo-abo/swiper][here]]. See [[https://oremacs.com/swiper/][here]].\\
     The completion framework itself. Waaay way smaller than =helm=, with less
     functionalities. But since I was using about 5% of =helm=, it doesn't matter

     From [[https://github.com/PythonNut/historian.el][here]].\\
     =ivy-historian= persists the =ivy= candidates in a file.
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-historian)
     #+END_SRC

     =ivy-hydra= transforms =ivy-dispatching-done= into
     =ivy-dispatching-done-hdyra= and adds an =hydra= to =ivy= minibuffers.\\
     (It's suppose to be bound on =C-o=, but this binding his conflicting with
     =evil-jump-backward=, so instead I chose =C-M-o=)
     #+BEGIN_SRC emacs-lisp
       (use-package ivy-hydra)
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       (use-package ivy
         :diminish ivy-mode
         :bind (
                ("C-x b" . ivy-switch-buffer)
                :map ivy-minibuffer-map
                ("C-M-o" . hydra-ivy/body)
                )
         :init
         ;; Add recent files and bookmarks to ivy-switch-buffer
         (setq ivy-use-virtual-buffers t)
         ;; Show the fullpath for the recent files in ivy-switch-buffer
         (setq ivy-virtual-abbreviate 'fullpath)
         ;; Use ivy as completion system for projectile
         (setq projectile-completion-system 'ivy)
         ;; Require to type ~/ to go home, instead of just ~
         (setq ivy-magic-tilde nil)
         ;; Allow minibuffer commands in minibuffer... MINIBUFFERCEPTION \o/
         (setq enable-recursive-minibuffers t)
         :config
         (ivy-historian-mode t)
         (ivy-mode t))
     #+END_SRC
**** =counsel=
     =counsel= is a collection of replacement functions for various Emacs
     commands, infused with =ivy=.

     A small helper function to call =counsel-ag= on the current directory
     automaticaly, not the project root, since it's what I want to do most of the time.
     #+begin_src emacs-lisp
       (defun lrn/counsel-ag (arg)
         "Call counsel-ag on the current directory. If ARG is present, make it interactive"
         (interactive "P")
         (if (equal arg nil)
             (counsel-ag nil default-directory)
           (counsel-ag)))
     #+end_src

     #+BEGIN_SRC emacs-lisp
       (use-package counsel
         :diminish counsel-mode
         :bind (
                ("C-x y" . counsel-yank-pop)
                ;; Bind counsel-ag to C-S-s
                ("C-S-s" . lrn/counsel-ag)
                )
         :init
         ;; Override the binding descriptions with counsel stuff
         (setq counsel-mode-override-describe-bindings t)
         :config
         (counsel-mode t))
     #+END_SRC

** Keybindings help
*** =guide-key=
    From [[https://github.com/kai2nenobu/guide-key][here]].

    =guide-key= is a cool little package that shows a popup with the possibles
    key-bindings when you start typing. Really useful to discover a lot of cool
    bindings !
    #+BEGIN_SRC emacs-lisp
      ;; (use-package guide-key
      ;;   :diminish guide-key-mode
      ;;   :init
      ;;   (setq guide-key/guide-key-sequence t) ; Trigger the guide for any binding
      ;;   (setq guide-key/popup-window-position 'bottom)
      ;;   (setq guide-key/align-command-by-space-flag t)
      ;;   (setq guide-key/idle-delay 0.75)
      ;;   :config
      ;;   (progn
      ;;     (guide-key-mode 1)))
    #+END_SRC
*** =which-key=
    From [[https://github.com/justbur/emacs-which-key][here]].

    Based on =guide-key=, it was developped for [[https://www.google.com/search?client=firefox-b-ab&q=github+spcemacs][Spacemacs]]. It does the same
    things, but... in a cooler way. Maybe.

    Let's give it a shot and see what it worth.
    #+BEGIN_SRC emacs-lisp
      (use-package which-key
        :diminish which-key-mode
        :init
        (setq which-key-popup-type 'side-window)
        (setq which-key-idle-delay 0.75)
        :config
        (which-key-mode t))
    #+END_SRC

*** =free-keys=
    From [[https://github.com/Fuco1/free-keys][here]].\\
    This cool package shows the free bindings available for the current buffer.

    Used with =describe-personal-bindings= (from =bind-key=), it helps a lot to
    define bindings that will not conflict with existing ones.
    #+BEGIN_SRC emacs-lisp
      (use-package free-keys
        :init
        (setq free-keys-modifiers '("" "C" "M" "C-M" "M-S")))
    #+END_SRC
*** =find-library=, =find-variable= and =find-function=
    From [[https://emacsredux.com/blog/2014/06/18/quickly-find-emacs-lisp-sources/][here]].\\
    Two very useful command to see the souce of a library, package, function,
    variable etc...
    Let's bind them so I can use them easily.

    #+BEGIN_SRC emacs-lisp
      (bind-key "C-h C-l" 'find-library-other-window global-map)
      (bind-key "C-h C-v p" 'find-variable-at-point global-map)
      (bind-key "C-h C-v o" 'find-variable-other-window global-map)
      (bind-key "C-h C-f" 'nil global-map)
      (bind-key "C-h C-f k" 'find-function-on-key-other-window global-map)
      (bind-key "C-h C-f p" 'find-function-at-point global-map)
      (bind-key "C-h C-f o" 'find-function-other-window global-map)
    #+END_SRC

*** =describe-face=
    Let's add a binding to invoke =describe-face= quickly.
    #+BEGIN_SRC emacs-lisp
      (bind-key "C-h C-y" 'describe-face global-map)
    #+END_SRC
** Sessions
   Emacs can save and restore the current session. Convenient since I'm closing
   Emacs often !

   Themes settings are also stored in the .desktop file... So if I change
   settings with =customize-face= then exit Emacs, those settings are restored
   the next time ! I don't like this behavior. Thanks to [[https://superuser.com/a/1155381][this]] post, there's a
   worakoung that reloads the actual theme after restoring the .desktop

   TODO: Since I start using =--daemon= / =emacsclient=, I had to fix
   =desktop-save=mode= so I can restore frames in a new frame... But it seems to
   have broken the up-mentioned workaround...  will (try) to-fix someday.
   #+BEGIN_SRC emacs-lisp
     (let ((sessions-dir (concat user-emacs-directory "tmp/sessions")))
       (when (not (file-directory-p sessions-dir))
         (make-directory sessions-dir t))
       (setq desktop-path (list (concat user-emacs-directory "tmp/sessions"))))

     (desktop-save-mode)
     (setq desktop-restore-forces-onscreen nil)
     (setq desktop-load-locked-desktop t)

     ;; (add-to-list 'desktop-globals-to-save 'custom-enabled-themes)
     ;; (defun desktop-load-theme () "load custom theme" (interactive)
     ;; (dolist (th custom-enabled-themes) (load-theme th)))
     ;; (add-hook 'desktop-after-read-hook 'desktop-load-theme)
   #+END_SRC

** Custom-file
   Emacs use a custom-file to store settings set by =M-x customize= and other
   stuff.

   Let's configure it.
   #+BEGIN_SRC emacs-lisp
     (setq custom-file (concat user-emacs-directory "config/custom.el"))
   #+END_SRC

   And load it at startup.
   #+BEGIN_SRC emacs-lisp
     (load custom-file)
   #+END_SRC
** =Dired=
   I want to use =dired-mode= more often, it seems really powerful !
   Let's customize some settings

   =dired-dwim-target= allows to 'auto-detect' the target for various operations
   such as copy, delete, etc... (If there's a split window with a =Dired=
   buffer, it'll assume that you want to target this directory)
   #+BEGIN_SRC emacs-lisp
     (setq dired-dwim-target t)
   #+END_SRC

   Always copy directory recursively without confirmation
   #+BEGIN_SRC emacs-lisp
     (setq dired-recursive-copies 'always)
   #+END_SRC

   The basic =ls= flags are quite limited (=-al=), let's add s'more, such as
   human-readable sizes
   #+BEGIN_SRC emacs-lisp
     (setq dired-listing-switches "-lah")
   #+END_SRC

   Auto-update the =dired= buffers if the content of a directory change.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook 'auto-revert-mode)
   #+END_SRC

   You now you can edit permissions directly from within =dired= ?
   #+BEGIN_SRC emacs-lisp
     (setq wdired-allow-to-change-permissions t)
   #+END_SRC

*** =dired+=
    From [[https://www.emacswiki.org/emacs/DiredPlus][here]].\\
    =dired+= is a package that provides additional features to the basic
    =dired-mode=
    However, I had to intall it manually, since it's not present on
    =MELPA= anymore ='(
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'load-path (concat user-emacs-directory "config/dired-plus"))
      (require 'dired+)
    #+END_SRC

    I found the builtin colors for =dired+= kind of ugly. Let's disable them.
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'font-lock-maximum-decoration '(dired-mode . nil))
      (add-to-list 'font-lock-maximum-decoration '(wdired-mode . nil))
    #+END_SRC

*** =dired-narrow=
    From [[https://github.com/Fuco1/dired-hacks/blob/master/dired-narrow.el][here]].\\
    A cool package that allows to filter files by name ! (See [[http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/][here]])

    In a =dired= buffer, hit =C-c C-n= to invok =dired-narrow= and type a string to
    filter. (hit =C-u C-c C-n= for =dired-narrow-regexp= !)\\
    When done, hit =g r= (=revert-buffer=) to remove the filters.
    #+BEGIN_SRC emacs-lisp
      (defun lrn/dired-narrow (arg)
        (interactive "P")
        (if (equal arg nil)
            (dired-narrow)
          (dired-narrow-regexp)))

      (use-package dired-narrow
        :init
        (bind-key "C-c C-n" 'lrn/dired-narrow dired-mode-map))
    #+END_SRC

*** =dired-quick-sort=
    See [[https://gitlab.com/xuhdev/dired-quick-sort][here]].
    Add a cool sorting menu to =dired=, to sort by name, time, size, extension,
    you name it...

    WARNING: Doesn't work on Mac OS, since =ls= doesn't support =--dired= option.
    #+BEGIN_SRC emacs-lisp
      (unless (string-equal system-type "darwin")
        (use-package dired-quick-sort
          :config
          (dired-quick-sort-setup))
        )
    #+END_SRC
** Emacs server
   Let's add a binding to kill the Emacs server.
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-x C-S-c" 'kill-emacs global-map)
   #+END_SRC
** Suspend
   There's a command to suspend the frame : =suspend-frame=. Pretty cool when
   using =Emacs= from terminal, but very dangerous in GUI. The frame is
   suspended and cannot be recovered easily !

  Even worse, it's bound on =C-x C-z=, and since I use =C-z= as =C-x= in Dvorak,
  is trigger it A LOT. Let's unbind this stuff.

  #+BEGIN_SRC emacs-lisp
    (global-unset-key (kbd "C-z C-z"))
  #+END_SRC

** Sudo
   Because it's cool to use Emacs to edit files as root. I know it can be done by
   manually opening the file with =TRAMP= by using the =/sudo::= prefix, but
   I'm a lazy boy...

   Let's use two packages to do all the work for me ;)

   From here [[https://github.com/ncaq/auto-sudoedit][here]].\\
   This package automaticaly prompt for the root password when opening a
   protected file. However, it doesn't work if the file is opened from the
   terminal with =emacsclient=, and there is no command to re-open the file as root.
   #+BEGIN_SRC emacs-lisp
     (use-package auto-sudoedit
       :diminish auto-sudoedit-mode
       :config
       (auto-sudoedit-mode t))
   #+END_SRC

   From here [[https://github.com/nflath/sudo-edit][here]].\\
   This package completes the previous one, it allows to manually open/re-open a
   file as root, and displays a warning at the top of the buffer. I'll use it
   when =auto-sudoedit= is not triggered.
   #+BEGIN_SRC emacs-lisp
     (use-package sudo-edit
       :bind (
              :map lrn/custom-map
              ("r" . sudo-edit))
       :config
       (sudo-edit-indicator-mode t))
   #+END_SRC
* Persitency
** =backup= and =auto-save=
   I love to keep my backups and auto-saves neatly in separates directories.
   This is the first settings I used when I start using Emacs in 2016, I should
   review them someday.
   #+BEGIN_SRC emacs-lisp
     (let ((backup-dir (concat user-emacs-directory "tmp/backups"))
           (auto-saves-dir (concat user-emacs-directory "tmp/auto-saves")))
       (dolist (dir (list backup-dir auto-saves-dir))
         (when (not (file-directory-p dir))
           (make-directory dir t)))
       (setq backup-directory-alist `(("." . ,backup-dir))
             auto-save-file-name-transforms `((".*" ,auto-saves-dir t))
             auto-save-list-file-prefix (concat auto-saves-dir ".saves-")
             tramp-backup-directory-alist `((".*" . ,backup-dir))
             tramp-auto-save-directory auto-saves-dir))

     (setq backup-by-copying t    ; Don't delink hardlinks
           delete-old-versions t  ; Clean up the backups
           version-control t      ; Use version numbers on backups,
           kept-new-versions 5    ; keep some new versions
           kept-old-versions 2)   ; and some old ones, too
   #+END_SRC

** History
   From [[http://pages.sachachua.com/.emacs.d/Sacha.html#org40a3abb][here]] (and from [[https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html][here]] too)
   It's cool to be able to re-run commands, searches and stuff from a previous session
   when opening Emacs.

   #+BEGIN_SRC emacs-lisp
     (setq savehist-file (concat user-emacs-directory "tmp/savehist"))
     (savehist-mode +1)
     (setq savehist-save-minibuffer-history +1)
     (setq savehist-additional-variables
           '(kill-ring
             search-ring
             regexp-search-ring))
   #+END_SRC

** =save-place=
   =save-place-mode= saves the current point location when I close a
   file or Emacs.
   So when I come back, the point position is restored !
   #+BEGIN_SRC emacs-lisp
     (save-place-mode t)
   #+END_SRC

* Editing
  Some settings I didn't know where to put... not really Programming stuff, but
  kinda' quand meme.

** Encoding
   Set default encoding to UTF-8, because it's most common. And the coolest !
   #+BEGIN_SRC emacs-lisp
     (set-language-environment "UTF-8")
   #+END_SRC

** Trailing whitespaces
   Always highlight trailing whitespaces for =prog-mode=, even though they are
   automatically deleted on save.
   #+BEGIN_SRC emacs-lisp
     (add-hook 'prog-mode-hook '(lambda () (setq show-trailing-whitespace t)))
   #+END_SRC

** Indentation
   Always indent with spaces, unless specified
   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

   Display tabs with a 2 characters width, to horrible nesting
   #+BEGIN_SRC emacs-lisp
     (setq-default tab-width 2)
   #+END_SRC

*** =highlight-indent-guide=
    From [[https://github.com/DarthFennec/highlight-indent-guides][here]].

    =highlight-indent-guide= makes indentation easier to understand with some
    sweet highlighting.
    #+BEGIN_SRC emacs-lisp
      (use-package highlight-indent-guides
        :diminish highlight-indent-guides-mode
        :hook ((prog-mode yaml-mode) . highlight-indent-guides-mode)
        :init
        (setq highlight-indent-guides-method 'character))
    #+END_SRC

*** =aggressive-indent=
    From [[https://github.com/Malabarba/aggressive-indent-mode][here]].

    This package is suppose to do a great job with code indentation, even during
    shitfing, transposing, slurping etc.

    TODO: Maybe it's a bit TOO aggressive in some modes... I'll probably disable
    it locally.
    #+BEGIN_SRC emacs-lisp
      (use-package aggressive-indent
        :hook (prog-mode . aggressive-indent-mode))
    #+END_SRC

** Case
   From [[https://wikemacs.org/wiki/Subword-mode][here]].\\
   Treat lower/uppper CamelCase as separate words
   #+BEGIN_SRC emacs-lisp
     (global-subword-mode 1)
     (diminish-minor-mode 'subword 'subword-mode)
   #+END_SRC
** Cursor width
   From [[http://pragmaticemacs.com/emacs/adaptive-cursor-width/][here]].
   Make the cursor the full width of the underlying character (TAB, etc).
   #+BEGIN_SRC emacs-lisp
     (setq x-stretch-cursor t)
   #+END_SRC
** Auto revert
   From [[http://pragmaticemacs.com/emacs/automatically-revert-buffers/][here]].
   Automatically update the buffer if the associated file on the disk has changed.
   If the buffer has unsaved changes, Emacs will prompt.
   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode t)
   #+END_SRC
** Parens
   See [[http://ergoemacs.org/emacs/emacs_insert_brackets_by_pair.html][here]] and [[https://www.emacswiki.org/emacs/ElectricPair][here]].\\
   Automatically write the closing quote, bracket, parenthesis… you know what I
   mean.
   Don't forget to disable =electric-pair-mode= for lispy languages,
   =smartparens= doest it instead.
   #+BEGIN_SRC emacs-lisp
     (electric-pair-mode t)
   #+END_SRC

   Support a few more pairs. (See [[http://ergoemacs.org/emacs/emacs_insert_brackets_by_pair.html][here]])
   #+BEGIN_SRC emacs-lisp
     (setq electric-pair-pairs
           '((?` . ?`)))
   #+END_SRC
** Sentence delimitation
   Sentence end with a single space. Because I said it.
   #+BEGIN_SRC emacs-lisp
     (setq sentence-end-double-space nil)
   #+END_SRC

** Folding
*** =hideshow=
    From [[https://www.emacswiki.org/emacs/HideShow][here]].\\
    Emacs requires a mode to handle folding.
    Let's run with =hideshow=, which is built-in and really efficient.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'prog-mode-hook 'hs-minor-mode)
      (diminish-minor-mode 'hideshow 'hs-minor-mode)
    #+END_SRC

*** =vimish-fold=
    From [[https://github.com/mrkkrp/vimish-fold][here]].\\
    This package provide Vim-like folds. That's pretty cool, I can do what I
    want, the folds are even persistent... but it's a bit less intuitive than
    =hideshow=. Since I don't fold much, I prefer =hideshow=.

    However, I'll keep the configuration, in case I want to give it a shot someday.
    #+BEGIN_SRC emacs-lisp
      ;; (use-package vimish-fold
      ;;   :init
      ;;   (setq vimish-fold-dir (concat user-emacs-directory "vimish-fold"))
      ;;   (setq vimish-fold-persist-on-saving t)
      ;;   :config
      ;;   (vimish-fold-global-mode t))
    #+END_SRC

    From [[https://github.com/alexmurray/evil-vimish-fold][here]].\\
    This package adds =evil= bindings for =vimish-fold=
    #+BEGIN_SRC emacs-lisp
      ;; (use-package evil-vimish-fold
      ;;   :defer t
      ;;   :config
      ;;   (evil-vimish-fold-mode t))
    #+END_SRC
** Selection
*** =expand-region=
    =expand-region= ([[https://github.com/magnars/expand-region.el][here]]) allows to expand the selection by semantic units...
    wathever that means.\\
    From what I undertand, it first selects the word, then the quote, the
    sentence, the block, etc... Sounds great.
    I probably can do the same with =visual= state of =evil=...

    #+BEGIN_SRC emacs-lisp
      (use-package expand-region
        :bind (
               ("C-M-=" . er/expand-region)
               ("C-M--" . er/contract-region)))
    #+END_SRC

*** =ace-jump-mode=
    From [[https://github.com/winterTTr/ace-jump-mode][here]].\\
    I always loved Vim's =EasyMotion=, even though I never used it that much.
    Basically, it allows me to jump to the desired occurence of a word in the
    displayed content by just pressing a key.
    I guess it's never too late :)

    Just hit =C-c SPC=, hit the char you wanna search and enjoy !
    (By default, it will search for words. If you want to search chars, you can
    hit =C-u C-c SPC=, or even =C-u C-u C-c SPC= to search for lines)
    #+BEGIN_SRC emacs-lisp
      (use-package ace-jump-mode
        :bind (
               :map evil-normal-state-map
               ("C-c SPC" . ace-jump-mode)
               ("C-x SPC" . ace-jump-mode-pop-mark)))
    #+END_SRC
** Transpose
   Emacs has cool built-in feature to transpose stuff, such as
   =transpose-words=, =transpose-chars=, =transpose-lines=...
   Very usefull and kinda' new for a Vim guy.

   By default, only =M-t= (=transpose-words=) and =C-x C-t= (=transpose-lines=)
   are bound.

   Let's create a map to access all of them, inside my custom map.
   I'll maybe have to type a few more keys, but since I don't use them that
   often, I won't mind.

   TODO: Maybe an =hydra= instead ? Or maybe I can delete this map... since the
   basic transpose commands (chars, words, lines) are bound by default, and I
   unbound C-t in evil-normal-state... It's a good opportunity to learn the
   default bindings
   #+BEGIN_SRC emacs-lisp
     (bind-keys :map lrn/custom-map
                :prefix "C-t"
                :prefix-map lrn/transpose-map
                :prefix-docstring "Keymap for transpose commands"
                ("w" . transpose-words)
                ("c" . transpose-chars)
                ("l" . transpose-lines)
                ("p" . transpose-paragraphs)
                ("e" . transpose-sexps)
                ("s" . transpose-sentences)
                ("r" . transpose-regions))
   #+END_SRC
** Align
*** =ialign=
    I often like to align stuff, like variables name, lists, numbers etc...
    Emacs provides few functions to do alignment.\\
    I found =ialign= ([[https://github.com/mkcms/interactive-align][here]]) to be a good alternative to =align-regexp=, as it has more functionalities.

    Let's bind it to =C-x C-a=.\\
    I like to apply the alignement on the whole line (i.e. align at each space).
    To disable the repetition, hit =C-c C-r=
    #+BEGIN_SRC emacs-lisp
      (use-package ialign
        :bind (
               :map lrn/custom-map
               ("a" . ialign))
        :init
        ;; Change the default regex to align by the first space
        (setq ialign-initial-regexp "\\( \\)")
        ;; I want to repeat the alignment throughout the lines
        (setq ialign-initial-repeat t))
    #+END_SRC
** =undo-tree=
   From [[http://www.dr-qubit.org/undo-tree.html][here.]] See [[https://www.emacswiki.org/emacs/UndoTree][here]].\\
   Emacs does almost everything well... except undos ! That's a nightmare
   compare to Vim.

   Hopefully, some guys try to make something 'similar' to Vim, despite the
   Emacs limitations.

   =undo-tree= provides a cool... undo-tree, with timestamps, persistent undo
   and such. Definitly not perfect, but better that nothing.
   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :diminish undo-tree-mode
       :init
       ;; Set a cutom undo directory, and enable persistent undo
       (setq undo-tree-history-directory-alist `(("." . ,(concat user-emacs-directory "tmp/undo"))))
       (setq undo-tree-auto-save-history t)
       (setq undo-tree-visualizer-timestamps t)
       (setq undo-tree-visualizer-diff t)
       :config
       (progn
         (global-undo-tree-mode)))
   #+END_SRC
** =move-text=
   From [[https://github.com/emacsfodder/move-text][here]].\\
   =move-text= allows to text up and down with =<M-up>= / =<M-down>=, like in VSCode
   #+BEGIN_SRC emacs-lisp
     (use-package move-text
       :config
       (move-text-default-bindings))
   #+END_SRC
** =rainbow-mode=
   From [[https://github.com/emacsmirror/rainbow-mode][here]].
   Because it can be usefull to visualise the actual color of hex colors, not
   only in =CSS Mode= (Okay, sometimes it will color stuff that doesn't need to
   be... meeeeeeeh, I don't care.).
   #+BEGIN_SRC emacs-lisp
     (use-package rainbow-mode
       :diminish rainbow-mode
       :hook (prog-mode . rainbow-mode))
   #+END_SRC
** Mark
   By default, =set-mark-command= is bound on =C-@= and =C-SPC=.\\
   =C-@= is totally unpractical, period.

   However, I prefere to use =C-SPC= to invoke =company-complete=, like
   Intellisence in VSCode. (and since I don't use =set-mark-command= with
   =evil=, but =evil-visual=... I doesn't matter.)

   So, let's remap =set-mark-command= on =C-c C-SPC=, to match his brother
   =C-x C-SPC= (=pop-global-mark)
   #+BEGIN_SRC emacs-lisp
     (bind-key "C-c C-SPC" 'set-mark-command global-map)
   #+END_SRC

** Default mode
   I prefer =text-mode= over =fundamental-mode= as default =major-mode=.

   #+BEGIN_SRC emacs-lisp
     (setq-default major-mode 'text-mode)
   #+END_SRC
** Text
*** =refill-mode=
    See [[https://www.emacswiki.org/emacs/RefillMode][here]].\\
    I like to have a nice formatting to write text.\\
    =refill-mode= does a pretty good job to keep text wrapped, making nice
    paragraphs, by auto-filling at =fill-column= length.

    Let's add a shortcut to enable =refill-mode=, instead of having it
    automaticaly on.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "C-c q") 'refill-mode)
    #+END_SRC
* Windows and buffers
** Kill this buffer
   Here's a small custom wrapper for =kill-buffer-and-window= /
   =kill-this-buffer=.

   If called without prefix, it kills the current buffer and window, otherwise, it
   just kills the buffer.

   #+BEGIN_SRC emacs-lisp
     (defun lrn/kill-this-buffer-and-window (arg)
       "Kill the current buffer and delete the selected window. If call with a preix argument, just kill the buffer."
       (interactive "P")
       (if (equal arg nil)
           (kill-buffer-and-window)
         (kill-this-buffer)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x k") 'lrn/kill-this-buffer-and-window)
   #+END_SRC

** Window splitting
   Thanks again @HRS for those functions, really useful to split windows in a
   more friendly fashion.

   Always switch to the new window after splitting
   #+BEGIN_SRC emacs-lisp
     (defun hrs/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun hrs/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))
   #+END_SRC

   Bind those 2 functions. I had to overwrite Evil map.
   #+BEGIN_SRC emacs-lisp
     (bind-key "v" 'hrs/split-window-right-and-switch evil-window-map)
     (bind-key "C-v" 'hrs/split-window-right-and-switch evil-window-map)
     (bind-key "s" 'hrs/split-window-below-and-switch evil-window-map)
     (bind-key "S" 'hrs/split-window-below-and-switch evil-window-map)
     (bind-key "C-s" 'hrs/split-window-below-and-switch evil-window-map)
     (bind-key "C-S-s" 'hrs/split-window-below-and-switch evil-window-map)
   #+END_SRC
** Scratch buffers
*** Mooooore !
    A cool HRS function to generate new scratch buffers.
    Can be used with =M-x hrs/generate-scratch-buffer= to create a scratch buffer
    in the current pane.
    #+BEGIN_SRC emacs-lisp
      (defun hrs/generate-scratch-buffer ()
        "Create and switch to a temporary scratch buffer with a random
             name."
        (interactive)
        (switch-to-buffer (make-temp-name "scratch-")))
    #+END_SRC

    Let's bind it on my custom map
    #+BEGIN_SRC emacs-lisp
      (bind-key "S" 'hrs/generate-scratch-buffer lrn/custom-map)
    #+END_SRC

    I want to be able to spawn scratch buffers in a new split-window, horizontal
    or vertical.
    Let's make a small keymap on =C-w C-n= (instead of =evil-window-new=), and
    bind two custom functions to do what I want, A.K.A, spawning a horizontal-split
    scratch buffer with =C-w C-n s=, and a vertical-split one with =C-w C-n v=

    First, a function to spawn the scratch buffers
    #+BEGIN_SRC emacs-lisp
      (defun lrn/spawn-scratch-buffer (orientation)
        "Spawn a scratch buffer in a new window. Orientation can be either 'horizontal' or 'vertical'"
        (cond ((eq orientation 'horizontal) (hrs/split-window-below-and-switch))
              ((eq orientation 'vertical) (hrs/split-window-right-and-switch)))
        (hrs/generate-scratch-buffer))
    #+END_SRC

    And two other function to spawn vertically or horizontaly (At first, I tried
    to make lambdas, it works great, but then =guide-key= displays ?? as the
    function name...)
    #+BEGIN_SRC emacs-lisp
      (defun lrn/spawn-scratch-buffer-horizontal ()
        (interactive)
        (lrn/spawn-scratch-buffer 'horizontal))

      (defun lrn/spawn-scratch-buffer-vertical ()
        (interactive)
        (lrn/spawn-scratch-buffer 'vertical))
    #+END_SRC

    Then, the map and the bindings
    #+BEGIN_SRC emacs-lisp
      ;; Unbind C-w C-n (evil-new-window)
      (bind-key "C-w C-n" nil evil-motion-state-map)

      (bind-keys :map evil-window-map
                 :prefix "C-n"
                 :prefix-map lrn/scratchbuffer-map
                 :prefix-docstring "Keymap for splitted scratchbuffers."
                 ("s" . lrn/spawn-scratch-buffer-horizontal)
                 ("v" . lrn/spawn-scratch-buffer-vertical))
    #+END_SRC

*** =persistent-scratch=
    Thanks to [[https://github.com/Fanael/persistent-scratch][this]] package, I can have persistent scratch buffers. They are
    automatically saved and restored with Emacs.\\
    That's cool when I mess around with scratch buffers and I don't want to lose
    them, since I have the tendency to close Emacs quite frequently.

    By default, only the buffers named =*scratch*= are saved. I also want to save
    the scratch buffer that I spawn.
    Let's fix that.

    Fist, define a custom check function to match all scratch buffers.
    #+BEGIN_SRC emacs-lisp
      (defun lrn/persistent-scratch-custom-scratch-buffer-p ()
        "Return non-nil iff the current buffer's name is a scratch one"
        (or
         (string= (buffer-name) "*scratch*")
         (string-match "^scratch-[A-Za-z0-9]\\{6\\}$" (buffer-name))))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package persistent-scratch
        :init
        ;; Use my custom function to check buffers name to know what to save
        (setq persistent-scratch-scratch-buffer-p-function 'lrn/persistent-scratch-custom-scratch-buffer-p)
        :config
        (progn
          (persistent-scratch-setup-default)))
    #+END_SRC
** =winner-mode=
   See [[https://www.emacswiki.org/emacs/WinnerMode][here]].\\
   Allow to switch back and forth between window configuration with =C-c <left>=
   and =C-c <right>=!
   So useful.
   #+BEGIN_SRC emacs-lisp
     (winner-mode t)
   #+END_SRC
** Kill all other buffers
   From [[https://stackoverflow.com/a/14161165][here]].
   A usefull function to do some cleanup when I'm having t many open
   buffers and that I'm too lazy to kill them in =C-x C-b= (=ibuffer=)

   TODO: Find a good binding for it :)
   #+BEGIN_SRC emacs-lisp
     (defun lrn/kill-other-buffers ()
       (interactive)
       (mapc 'kill-buffer (cdr (buffer-list (current-buffer)))))
   #+END_SRC
** Manage buffers
*** =ibuffer=
    See [[https://www.emacswiki.org/emacs/IbufferMode][here]].\\
    I really like =helm-mini= to quickly find a buffer or re-open a recently
    close file. But when it comes to manage multiple buffers at the same time...
    I can't get used to it's shitty bindings.\\
    I prefer =ibuffer=, who comes with =dired= like bindings, group features and
    so much more.

    There's some cool tweaks to make =ibuffer= even cooler. See [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][here]] !

    Here's a helper function stolen from @[[https://github.com/purcell/emacs.d/blob/master/lisp/init-ibuffer.el#L10][purcell]]'s conf (see [[https://github.com/purcell/emacs.d/blob/master/lisp/init-ibuffer.el#L10][here]]) to enable
    =ibuffer-vc= filter groups.
    #+BEGIN_SRC emacs-lisp
      (defun lrn/ibuffer-set-up-preferred-filters ()
        (interactive)
        (ibuffer-vc-set-filter-groups-by-vc-root)
        (unless (eq ibuffer-sorting-mode 'filename/process)
          (ibuffer-do-sort-by-filename/process)))
    #+END_SRC

    Let's configure =ibuffer=.\\
    I also add =ibuffer-vc= (see [[https://github.com/purcell/ibuffer-vc][here]]) to group buffers by VC root. It's usefull
    to easily know which buffer belongs to which project, without being in a
    =Projectile= thing.
    #+BEGIN_SRC emacs-lisp
      (bind-key "C-x C-b" 'ibuffer global-map)

      ;; Enable ibuffer-auto-mode to auto-refresh buffer if changes occur on the disk
      (add-hook 'ibuffer-hook 'ibuffer-auto-mode)
      ;; Enable ibuffer-vc filter groups when I open ibuffer
      (add-hook 'ibuffer-hook 'lrn/ibuffer-set-up-preferred-filters)

      (use-package ibuffer-vc)
      ;; Hide empty filter-groups
      (setq ibuffer-show-empty-filter-groups nil)
      ;; Here's a custom filter-group, in case I don't want ibuffer-vc filtering,
      ;; but style have some groups I like.
      (setq ibuffer-saved-filter-groups
            '(("basic"
               ("Org" (mode . org-mode))
               ("Magit" (name . "^magit:*"))
               ("Helm" (name . "^\*helm*"))
               )))

      ;; Let's create a custom column with file size displayed in a human-redeable
      ;; style...
      (define-ibuffer-column size-h
        (:name "Size" :inline t)
        (cond
         ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
         ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
         (t (format "%8d" (buffer-size)))))
      ;; ... then apply it by redefining ibuffer-formats.
      (setq ibuffer-formats
            '((mark modified read-only " "
                    (name 18 18 :left :elide)
                    " "
                    (size-h 9 -1 :right)
                    " "
                    (mode 16 16 :left :elide)
                    " "
                    filename-and-process)))
      ;; I want to be able to switch back to ibuffer-vc filter-groups in ibuffer,
      ;; if I disabled them.
      (evil-define-key 'normal ibuffer-mode-map (kbd "s V") 'lrn/ibuffer-set-up-preferred-filters)
    #+END_SRC

* Workspaces
  I just discovered that I can have workspaces in Emacs, just like in i3WM.\\
  I have to try this ! However I'm not sure what package to chooose, between
  =perspective.el=, =persp-mode= and =eyebrowse=...

  I also don't know how they interact with =projectile=.
  Let's try them all and see !

** =eyebrowse=
   From [[https://github.com/wasamasa/eyebrowse][here]]. Ressources [[http://pragmaticemacs.com/emacs/easily-manage-emacs-workspaces-with-eyebrowse/][here]],

   This package workspaces to Emacs, just like a TWM.
   Hit =C-c C-w=, then you can choose a workspace (0-9).\\
   Each workspace keeps a different window configuration, and it's saved by
   =desktop-save-mode=. Pretty cool.

   Apparently, it can work with =perspective=, with some additional code (see
   [[https://www.reddit.com/r/emacs/comments/6sffrd/am_i_misunderstanding_eyebrowse/dlcfhwk][here]]), so you can have multiple workspaces with 10 sub-workspaces in each
   one... Sounds great, but I don't find the proper way to do it.


   #+BEGIN_SRC emacs-lisp
     (use-package eyebrowse
       :bind (
              ;; That's stupid, I need to include the prefix in the binding... bug ?
              :map eyebrowse-mode-map
              ("C-c C-w h" . eyebrowse-prev-window-config)
              ("C-c C-w l" . eyebrowse-next-window-config)
              ("C-c C-w <left>" . eyebrowse-prev-window-config)
              ("C-c C-w <right>" . eyebrowse-next-window-config))
       :init
       ;; Circle through the workspaces.
       (setq eyebrowse-wrap-around t)
       ;; Create a scratch buffer in a new workspace.
       (setq eyebrowse-new-workspace 'hrs/generate-scratch-buffer)
       ;; Set the prefix to access eyebrowse-keymap
       (setq eyebrowse-keymap-prefix (kbd "C-c C-w"))
       ;; Always show the mode-line indicator, even if there's only one workspace
       (setq eyebrowse-mode-line-style t)
       :config
       ;; This is a custom face, so the active workspace is more visible in the mode-line.
       (set-face-attribute 'eyebrowse-mode-line-active nil
                           :inherit font-lock-builtin-face
                           :weight 'bold)
       (eyebrowse-mode t))
   #+END_SRC

* =TRAMP=
  =TRAMP= is great to remote-edit files with Emacs !
  I need to use it way more.

  TODO: Learn =TRAMP= !

  Use =ssh= by default
  #+BEGIN_SRC emacs-lisp
    (setq tramp-default-method "ssh")
  #+END_SRC
* =Org-mode=
** =org=
   From [[https://www.orgmode.org/fr/index.html][here]]. Full doc [[https://orgmode.org/org.html][here]].\\
   Let's install the latest =org= package and set some stuff.
   #+BEGIN_SRC emacs-lisp
     (use-package org
       :hook (
              (org-mode . (lambda ()
                            (setq show-trailing-whitespace t)
                            (refill-mode -1)
                            (auto-fill-mode t))))
       :init
       ;; Syntax highlight src blocks in org-mode
       (setq org-src-fontify-natively t)
       ;; Make tab work like in a code buffer for src blocks
       (setq org-src-tab-acts-natively t)
       ;; Use anothr window when editing a code snippet
       (setq org-src-window-setup 'other-window)
       ;; Log the date when a TODO is DONE
       (setq org-log-done 'time)
       ;; Remove footer when exporting in HTML mode
       (setq org-html-postamble nil))
   #+END_SRC
** Babel
   Allow Babel to evaluate these languages
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (ruby . t)
        (dot . t)
        (shell . t)
        (python . t)
        (gnuplot . t)))
   #+END_SRC

   Dont ask permission to run code blocks
   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   Disable the checkdock warnings for =emacs-lisp= code blocks.
   It floods the =modeline=... See [[https://emacs.stackexchange.com/a/16770][here]].
   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-src-mode-hook
               (lambda ()
                 (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc))))
   #+END_SRC
** Bullets
   It's way cooler to have graphicals bullets instead of plains *, don't you
   think ?
   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :hook (org-mode . org-bullets-mode))
   #+END_SRC
** Exports
   One of the best feature of =Org-mode= is it's capability to export org-files
   in a shitload of format !

   Want some markdown ?
   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
   #+END_SRC

   Want Beamer ?
   #+BEGIN_SRC emacs-lisp
     (require 'ox-beamer)
   #+END_SRC

   Want some f*cking Twitter Bootstrap ?
   #+BEGIN_SRC emacs-lisp
     (use-package ox-twbs)
   #+END_SRC

   Because it's cool to have nice text decorations in HTML
   #+BEGIN_SRC emacs-lisp
     (use-package htmlize)
   #+END_SRC

   Settings for LaTeX (WIP, tested on Linux, not OSX)
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-latex-packages-alist '("" "minted"))
     (setq org-latex-listings 'minted)
     (setq org-latex-pdf-process
           '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
             "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
   #+END_SRC

** Global bindings
   Because sometimes =org-mode= features are so great, I want to use them in
   every other mode !

   Let's make =org-open-at-point= globally available (in my custom-map, to avoid
   conflict with other major-modes...)
   #+BEGIN_SRC emacs-lisp
     (bind-key "o" 'org-open-at-point-global lrn/custom-map)
   #+END_SRC
* Programming
  I will put a lot of stuff in this section, sometimes not justified at all !
  But I don't know how to organize everything...

** Environment, PATH and stuff
*** PATH
    When Emacs is not run from a shell, it doesn't inherit from the user's PATH
    defined in his shell config.
    But there's package to fix that :)
    #+BEGIN_SRC emacs-lisp
      (use-package exec-path-from-shell
        :config
        (progn
          (when (memq window-system '(mac ns nil x))
            (exec-path-from-shell-initialize))))
    #+END_SRC
** VCS
   Everything needed to work with =Git= in the best conditions
*** =magit=
    From [[https://magit.vc/][here]], repo [[https://github.com/magit/magit][here]].\\
    Don't forget the [[https://github.com/magit/magit/wiki/Cheatsheet][cheatsheet]] :)

    =magit= is greaaaaaaat. So much great ! Every other Git client can get back at
    their moms house.
    Just hit =C-x g= (=magit-status=) and let the magic operate.

    I also add =evil-magit= to have =evil= bindings within =magit=
    #+BEGIN_SRC emacs-lisp
      (use-package magit
        :hook (
               (with-editor-mode . evil-insert-state))
        :bind (
               ("C-x g" . magit-status))
        :config
        (use-package evil-magit))
    #+END_SRC
*** Forge
    From [[https://github.com/magit/forge][here]].\\
    Add =Github= or =Gitlab= support to =Magit= !

    #+BEGIN_SRC emacs-lisp
      (use-package forge)
    #+END_SRC
*** =gist=
    From [[https://github.com/defunkt/gist.el][here]].\\
    A cool package to manage gists directly from within Emacs
    #+BEGIN_SRC emacs-lisp
      (use-package gist
        :bind (
               :map gist-list-menu-mode-map
               ("s" . gist-list-starred)
               ("u" . gist-list-user)
               ("t" . gist-list-push-tag-limit)
               ("p" . gist-list-push-visibility-limit)
               ("x" . gist-list-pop-limit)))
    #+END_SRC

    Let's make an =hydra= to have convenient bindings for all this cool =gist=
    commands !
    #+BEGIN_SRC emacs-lisp
      (defhydra lrn/hydra-make-gist (
                                     :hint nil
                                     :color blue
                                     :foreign-keys run)
        "
       ^Create private^  |  ^Create public^  |     ^List^    |    ^Other^
      ^^^^^^--------------------------------------------------------------
        [_r_] Region     |  [_R_] Region     | [_l_] All     |  [_q_] Quit
        [_b_] Buffer     |  [_B_] Buffer     | [_s_] Starred |
        ^^^^                                 | [_u_] User    |
      "
        ("r" gist-region-private)
        ("b" gist-buffer-private)
        ("R" gist-region)
        ("B" gist-buffer)
        ("l" gist-list)
        ("s" gist-list-starred)
        ("u" gist-list-user)
        ("q" nil))
      (bind-key "g" 'lrn/hydra-make-gist/body lrn/custom-map)
    #+END_SRC

    #+RESULTS:
    : lrn/hydra-make-gist/body

    I also need an hydra to help me remember all the =gist-list-mode= bindings.
    #+BEGIN_SRC emacs-lisp
      (defhydra lrn/hydra-gist-list-mode (
                                          :hint nil
                                          :color blue
                                          :foreign-keys run)
        "
            ^Edit^      |      ^Url^     |     ^Star^^^   |   ^Limit^     |   ^Other^
      ^^^^^^^^^^------------------------------------------------------------------------------------
      [_+_] Add buffer  | [_y_] Copy url | [_*_]^^ Star   | [_s_] Starred | [_RET_] Fetch (focus)
      [_-_] Remove file | [_b_] Browse   | [_\\^_] Unstar | [_u_] User    | [_TAB_] Fetch (no focus)
      [_e_] Edit desc.  |                           ^^^^^^| [_t_] Tag     | [_f_]   Fork
      [_k_] Kill        |                           ^^^^^^| [_p_] Public  | [_g_]   Reload
                                                  ^^^^^^^^| [_x_] Pop     | [_q_]   Quit
      "
        ("+" gist-add-buffer)
        ("-" gist-remove-file)
        ("e" gist-edit-current-description)
        ("k" gist-kill-current)
        ("y" gist-print-current-url)
        ("b" gist-browse-current-url)
        ("*" gist-star)
        ("^" gist-unstar)
        ("s" gist-list-starred)
        ("u" gist-list-user)
        ("t" gist-list-push-tag-limit)
        ("p" gist-list-push-visibility-limit)
        ("x" gist-list-pop-limit)
        ("RET" gist-fetch-current)
        ("TAB" gist-fetch-current-noselect)
        ("f" gist-fork)
        ("g" gist-reload)
        ("q" nil))
      (with-eval-after-load 'gist
        (bind-key "h" 'lrn/hydra-gist-list-mode/body gist-list-menu-mode-map))
    #+END_SRC

*** =git-gutter=
    From [[https://github.com/syohex/emacs-git-gutter-fringe][here]].\\
    Another Sublime package that I really like, makes atomic commits and partial
    staging so much easier.
    #+BEGIN_SRC emacs-lisp
      (use-package git-gutter-fringe
        :diminish git-gutter-mode
        :config
        (global-git-gutter-mode 1))

    #+END_SRC
** Fuzzy-finding and search
*** =helm-swoop=
    From [[https://github.com/ShingoFukuyama/helm-swoop][here]].
    =helm-swoop=, to do search in the buffers !
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm-swoop
      ;;   :bind (
      ;;          ("M-i" . helm-swoop)
      ;;          ("M-I" . helm-swoop-back-to-last-point)
      ;;          ("C-c M-i" . helm-multi-swoop)
      ;;          ("C-x M-i" . helm-multi-swoop-all)
      ;;          :map isearch-mode-map
      ;;          ("M-i" . helm-swoop-from-isearch)
      ;;          :map helm-swoop-map
      ;;          ("M-i" . helm-multi-swoop-all-from-helm-swoop))
      ;;   :config
      ;;   (progn
      ;;     (setq helm-swoop-split-with-multiple-windows t)
      ;;     (setq helm-swoop-split-direction 'split-window-horizontally)))
    #+END_SRC
*** =swiper=
    From [[https://oremacs.com/swiper/][here]].\\
    The fuzzy-finder based on =ivy=

    To search for the symbol-at-point, hit =M-n= after entering =swiper=.
    #+BEGIN_SRC emacs-lisp
      (use-package swiper
        :bind (
               ("M-i" . swiper)
               ;; Also bind swiper to C-s instead of isearch-forward, I don't use it anyway
               ("C-s" . swiper)))
    #+END_SRC
*** =ag=
    =ag=, AKA The Silver Searcher, is great to fuzzy-find stuff in files. It's
    needed by =projectile-ag=, but since I use =counsel-ag= (which is shipped
    with it's own =ag= implementation), it shoudn't be necessary.

    Nevertheless, it requires the "[[https://github.com/ggreer/the_silver_searcher][the_silver_searcher]]" binary installed on the system to
    work.
    #+BEGIN_SRC emacs-lisp
      (use-package ag)
    #+END_SRC
*** =isearch=
    I want to be able to navigate in =isearch-ring= to quickly use a previous
    pattern again, using =<up>= and =down=. See [[https://emacs.stackexchange.com/a/31336][here]].

    #+BEGIN_SRC emacs-lisp
      (bind-key "<up>" 'isearch-ring-retreat isearch-mode-map)
      (bind-key "<down>" 'isearch-ring-advance isearch-mode-map)
    #+END_SRC

    Show the match count.
    #+BEGIN_SRC emacs-lisp
      (setq isearch-lazy-count t)
    #+END_SRC
** Project management
*** =projectile=
    From [[https://github.com/bbatsov/projectile][here]]. Website [[https://www.projectile.mx/en/latest/][here]].\\
    =projectile= is another awesome package, allowing us to work with projects
    instead of just folders. So much possibilities, I still have a lot to learn
    about it.

    Here'a another @HRS function to use =ag= with =projectile= to search the
    symbol at point across the project.
    #+BEGIN_SRC emacs-lisp
      (defun hrs/search-project-for-symbol-at-point ()
        "Use `projectile-ag' to search the current project for `symbol-at-point'."
        (interactive)
        (projectile-ag (projectile-symbol-at-point)))
    #+END_SRC

    Behold, =projectile= ! With bindings for =ag= and integration with =neotree=
    and =helm=
    #+BEGIN_SRC emacs-lisp
      (use-package projectile
        :diminish projectile-mode
        :bind (
               :map projectile-mode-map
               ("C-c p s v" . hrs/search-project-for-symbol-at-point)
               ("C-c p" . projectile-command-map))
        :init
        (setq projectile-require-project-root nil)
        :config
        (progn
          (projectile-mode t)))
    #+END_SRC

    +Speaking of =helm=, don't forget =helm-projectile= ([[https://github.com/bbatsov/helm-projectile][here]]). See [[http://tuhdo.github.io/helm-projectile.html][here]].+
    #+BEGIN_SRC emacs-lisp
      ;; (use-package helm-projectile)
    #+END_SRC

    From [[https://github.com/ericdanan/counsel-projectile][here]]. Integrate =ivy=/=counsel= stuff into =projectile=
    #+BEGIN_SRC emacs-lisp
      (use-package counsel-projectile
        :config
        (counsel-projectile-mode))
    #+END_SRC
** Completion
*** =company=
    From [[https://github.com/company-mode/company-mode][here]]. Website [[http://company-mode.github.io/][here]].\\
    =company= is a completion framework pluggable with different backends to
    provide a cool completion during programming.
    I need to configure the popup style, because for now it looks like Windows
    95... but it works great !

    #+BEGIN_SRC emacs-lisp
      (use-package company
        :diminish (company-mode "Cpn")
        :bind (
               ("C-SPC" . company-complete)
               :map company-active-map
               ("?" . company-show-doc-buffer)
               ("<down>" . company-complete-common-or-cycle)
               ("M-n" . company-complete-common-or-cycle)
               ("M-j" . company-complete-common-or-cycle)
               ("C-n" . company-complete-common-or-cycle)
               ("C-j" . company-complete-common-or-cycle)
               ("<escape>" . company-abort)
               ("<tab>" . company-complete-selection))
        :init
        (setq company-tooltip-limit 30)                        ; bigger popup window
        (setq company-idle-delay 0)                          ; decrease delay before autocompletion popup shows
        (setq company-echo-delay 0)                            ; remove annoying blinking
        (setq company-begin-commands '(self-insert-command))   ; start autocompletion only after typing
        (setq company-minimum-prefix-length 1)
        (setq company-tooltip-align-annotations t)
        ;; Inherit faces from the current theme, looks nicer than the default Company colors
        (let ((bg (face-attribute 'default :background)))
          (custom-set-faces
           `(company-tooltip ((t (:inherit default :background ,(color-lighten-name bg 2)))))
           `(company-scrollbar-bg ((t (:background ,(color-lighten-name bg 10)))))
           `(company-scrollbar-fg ((t (:background ,(color-lighten-name bg 5)))))
           `(company-tooltip-selection ((t (:inherit font-lock-function-name-face))))
           `(company-tooltip-common ((t (:inherit font-lock-constant-face))))))
        :config
        (progn
          (global-company-mode)))
    #+END_SRC
*** =company-quickhelp=
    From[[https://github.com/expez/company-quickhelp][ here]].\\
    It's nice to have small popups with the documentation of the candidates in
    =company= :)
    #+BEGIN_SRC emacs-lisp
      (use-package company-quickhelp
        :init
        (setq company-quickhelp-delay 0.5)
        (setq company-quickhelp-use-propertized-text t)
        :config
        (company-quickhelp-mode))
    #+END_SRC
*** =company-box=
   From [[https://github.com/sebastiencs/company-box][here]].\\
   This package add icons to the =company= candidates !

   #+BEGIN_SRC emacs-lisp
     (use-package company-box
       :diminish company-box-mode
       :hook
       (company-mode . company-box-mode))
   #+END_SRC

** Snippets
*** =yasnippet=
    From [[https://github.com/joaotavora/yasnippet][here]]. Ressouces [[https://www.emacswiki.org/emacs/Yasnippet][here]], [[http://ergoemacs.org/emacs/emacs_templates.html][here]], [[http://pragmaticemacs.com/emacs/smart-text-templates-with-yasnippet/][here]], [[http://pragmaticemacs.com/emacs/smart-text-templates-with-yasnippet/][here]].

    TextMate-like snippets in Emacs ! I usually don't use a lot of snippets, but
    for very-repetitive stuff like control-structures, I have to admit, it's
    usefull.

    TODO: Fix binding conflict with =company=
    #+BEGIN_SRC emacs-lisp
      (use-package yasnippet
        :init
        (setq yas-snippet-dirs `(,(concat user-emacs-directory "snippets")))
        :config
        (yas-global-mode t))
    #+END_SRC
*** =ivy-yasnippet=
    From [[https://github.com/mkcms/ivy-yasnippet][here]].\\
    This package provides snippet preview using =ivy=.

    #+BEGIN_SRC emacs-lisp
      (use-package ivy-yasnippet
        :bind ("C-c & i" . ivy-yasnippet))
    #+END_SRC
** Documentation
*** =eldoc=
    From [[https://www.emacswiki.org/emacs/ElDoc][here]].\\
    =eldoc= shows the prototype of the function at point in the echo area.
    By default it only works for Lisp, but you can plug additional backends to
    support other languages. It's really nifty.

    Let's enable it globally
    #+BEGIN_SRC emacs-lisp
      (global-eldoc-mode t)
      (diminish-minor-mode 'eldoc 'eldoc-mode)
    #+END_SRC
** Syntax checking
*** =flycheck=
    From [[https://github.com/flycheck/flycheck][here]]. Website [[https://www.flycheck.org/en/latest/][here]].\\
    A great realtime syntax checking extension that works with a lot of
    backends.

    #+BEGIN_SRC emacs-lisp
      (use-package flycheck
        :config
        (progn
          (global-flycheck-mode)))
    #+END_SRC
** Languages
*** YAML
    From [[https://github.com/yoshiki/yaml-mode][here]].\\
    A major mode to edit YAML files :) Pretty good, with syntax highlighting,
    correct indenting etc...
    #+BEGIN_SRC emacs-lisp
      (use-package yaml-mode
        :hook (yaml-mode . (lambda ()
                             (refill-mode -1))))
    #+END_SRC
*** JSON
    Here's a major-mode ([[https://github.com/joshwnj/json-mode][here]]) to edit JSON, with syntax highlithing, indentation,
    linting etc :)
    #+BEGIN_SRC emacs-lisp
      (use-package json-mode)
    #+END_SRC
*** CMake
    From [[https://github.com/Kitware/CMake/blob/master/Auxiliary/cmake-mode.el][here]].\\
    A major mode for CMake files
    #+BEGIN_SRC emacs-lisp
      (use-package cmake-mode)
    #+END_SRC
*** Lisp
    Lisp, Emacs Lisp, Clojure... it's all the same for me ! I put eveything here.
**** =smartparens=
     According to [[https://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html#fnr.75][this]], =smartparens= ([[https://github.com/Fuco1/smartparens][here]]) is cooler than =paredit=, which I used so
     far (only for lispy languages)
     Let's give it a shot, it's always nice to have a good expression
     management... and it works with other pairs too ! Quotes, brackets and stuff.

     Maybe someday I'll get some ideas from [[http://pages.sachachua.com/.emacs.d/Sacha.html#orgdd725d2][here]] too :)
     #+BEGIN_SRC emacs-lisp
       (use-package smartparens
         :diminish smartparens-mode
         :config
         (progn
           (sp-use-smartparens-bindings)
           ;; Disable the highlight when spawning a pair, it doesn't go away
           ;; until exiting Insert mode or hitting backspace...
           (setq sp-highlight-pair-overlay nil)
           (require 'smartparens-config)))
     #+END_SRC

**** Parenthesis much ?
     All you need to avoid killing yourself when working with SO MUCH parenthesis
     !

     =rainbow-delimiters= colors each pair of paranthesis in a different color.
     It helps A LOT with readability issues.
     #+BEGIN_SRC emacs-lisp
       (use-package rainbow-delimiters)
     #+END_SRC

     There's also a lot a mode for editings \*lisp\*, so we need to enable
     =smartparens= and =rainbow-delimiters= for everyone of them.
     #+BEGIN_SRC emacs-lisp
       (setq lispy-mode-hooks
             '(clojure-mode-hook
               emacs-lisp-mode-hook
               lisp-mode-hook))

       (dolist (hook lispy-mode-hooks)
         (add-hook hook (lambda ()
                          (setq show-paren-style 'expression)
                          (electric-pair-local-mode -1)
                          (smartparens-strict-mode)
                          (show-smartparens-mode)
                          (rainbow-delimiters-mode))))
     #+END_SRC
**** Eval
     Evaluating lisp expressions to do stuff is great. I'm not sure if the
     following content is at the right place, it could also be in =Editing=...
     But it doesn't matter for now.

***** Eval prefix
      By default, there's only one content-evalutation binding, =C-x C-e= (=eval-last-sexp=)
      I'd like to also have binding for =eval-buffer=, =eval-region= and
      stuff.\\
      So let's make a map inside my custom map, and define some binding, should we ?

      TODO: Maybe an =hydra= instead ?
      #+BEGIN_SRC emacs-lisp
        (bind-keys :map lrn/custom-map
                   :prefix "e"
                   :prefix-map lrn/eval-map
                   :prefix-docstring "Keymap for evaluation commands"
                   ("e" . eval-last-sexp)
                   ("b" . eval-buffer)
                   ("r" . eval-region)
                   ("p" . eva-print-last-sexp)
                   ("d" . eval-defun))
      #+END_SRC

***** Eval and replace
      From [[https://emacsredux.com/blog/2013/06/21/eval-and-replace/][here]].\\
      This is GREAT. This function allows me to evaluate some s-exp and insert the
      output instead. Now I just need to learn some cool lisp stuff ^^'
      #+BEGIN_SRC emacs-lisp
        (defun lrn/eval-and-replace ()
          "Replace the preceding sexp with its value."
          (interactive)
          (backward-kill-sexp)
          (condition-case nil
              (prin1 (eval (read (current-kill 0)))
                     (current-buffer))
            (error (message "Invalid expression")
                   (insert (current-kill 0)))))
      #+END_SRC

      Let's bind this function on the =C-x C-e= map
      #+BEGIN_SRC emacs-lisp
        ;; C-x C-e s (eval-last-sexp)
        (bind-key "s" 'lrn/eval-and-replace lrn/eval-map)
      #+END_SRC
*** Python
    See [[https://vxlabs.com/2018/06/08/python-language-server-with-emacs-and-lsp-mode/][here]].

    Previously I was using =elpy= and =jedi= for Python development. Now I'm
    using =LSP=.\\
    So far it seems to work quite well, got the same features, but with just one
    ('ish) package.

    I kept =pipenv= to manage the virtual environments, no changes here.\\
    For =LSP= to work, I need to have the =pyls= package installed on the venv (or globally,
    if I'm a sac a merde).\\
    Don't forget to install it by running :
    #+BEGIN_SRC sh :tangle no
      pipenv install --dev 'python-language-server[all]'
    #+END_SRC

**** =pipenv=
     From [[https://github.com/pwalsh/pipenv.el][here]].\\
     A package that provides bindings for =pipenv=, cool for working with
     virtual envs.
     It's hard to find a good solution when it comes to venv in Emacs, most of
     the package rely on =pyenv=, =pyvenv= or wathever, but not on =pipenv=,
     which is the official recommendation =/ So for now it's kind of glitchy,
     half =pipenv=, half =pyvenv=...
     #+BEGIN_SRC emacs-lisp
       (use-package pipenv
         :hook (python-mode . pipenv-mode)
         :bind (
                :map pipenv-command-map
                ("w" . pyvenv-workon)
                ("p" . run-python)
                )
         :init
         (setenv "WORKON_HOME" (concat (getenv "HOME") "/.local/share/virtualenvs"))
         (setq
          pipenv-projectile-after-switch-function
          #'pipenv-projectile-after-switch-extended))
     #+END_SRC
*** C / CPP
    I'm now using =LSP= for C/C++ development, it works as good as the old
    =irony= or =rtags= setup, but way simpler.

    For =clangd= to work, you must generate a =compile_command.json= file. This
    file is already present if the project is built by =clang=.\\
    For the projects that use =make=, you can use =bear= to generate the JSON
    file.
    #+BEGIN_SRC sh :tangle no
       make clean
       bear make ...
    #+END_SRC

    You need to have =clangd= command available in your =PATH= for =lsp= to work
    with C files.\\
    It is included in the =llvm= package.
    #+BEGIN_SRC sh :tangle no
      pacman -S llvm
    #+END_SRC
**** 42 Headers
     From [[https://github.com/sullivanv/emacs][here]].\\
     Use the official 42 headers in C/CPP files.

     #+BEGIN_SRC emacs-lisp
       (load (concat user-emacs-directory "config/42/list.el"))
       (load (concat user-emacs-directory "config/42/string.el"))
       (load (concat user-emacs-directory "config/42/comments.el"))
       (load (concat user-emacs-directory "config/42/header.el"))

       (bind-key "h" 'header-insert lrn/custom-map)
     #+END_SRC

**** Indentation
     Indent with tabs for C/CPP files, displayed as 4 spaces.
     #+BEGIN_SRC emacs-lisp
       (setq-default c-basic-offset 4)

       (add-hook 'c-mode-hook (lambda ()
                                (setq tab-width 4)
                                (setq evil-shift-width 4)
                                (setq indent-tabs-mode t)))
     #+END_SRC

     Set C coding style to "linux" to not indent braces in C files
     #+BEGIN_SRC emacs-lisp
       (setq-default c-default-style "linux")
     #+END_SRC
**** Misc
     These are test settings for C/CPP, to remove.
     #+BEGIN_SRC emacs-lisp
       ;; (require 'semantic)
       ;; (require 'semantic/bovine/gcc)
       ;; (add-to-list 'semantic-default-submodes 'global-semanticdb-minor-mode)
       ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-local-symbol-highlight-mode)
       ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-scheduler-mode)
       ;; (add-to-list 'semantic-default-submodes 'global-semantic-idle-summary-mode)
       ;; (semantic-mode 1)
       ;; (global-ede-mode t)
       ;; (ede-enable-generic-projects)
     #+END_SRC
*** HTML
    Because editing HTML markup is my FAVORITE thing ever in development... I
    better have some cools packages to help me do it !

**** =emmet-mode=
     From [[https://github.com/smihica/emmet-mode][here]].\\
     Big-up to Adrien !
     Just kidding, =Emmet= is great for people like me who dislike writing HTML
     and/or CSS.
     Even just to write a base HTML 5 template... so much time saved !

     In =web-mode=, hit =C-j= to expand =emmet= snippets\\
     #+BEGIN_SRC emacs-lisp
       (use-package emmet-mode
         :after web-mode
         :bind (
                :map web-mode-map
                ("C-j" . emmet-expand-line)))
     #+END_SRC

**** =web-mode=
     From [[http://web-mode.org/][here]].\\
     =web-mode= allows me to edit HTML templates with cool features.

     TODO: Support all needed file types, Company.
     #+BEGIN_SRC emacs-lisp
       (use-package web-mode
         :mode ("\\.html?\\'" "\\.tpl\\.php\\'")
         :hook (
                (web-mode . emmet-mode)
                (web-mode . rainbow-mode))
         :init
         (setq web-mode-markup-indent-offset 2))
     #+END_SRC
*** JavaScript
    Aaaaah JavaScript <3 My old best friend... You'll always have a special
    place in my heart.

    Let's configure a decent IDE for you, you deserve it !\\
    I'm (mostly) using [[https://emacs.cafe/emacs/javascript/setup/2017/04/23/emacs-setup-javascript.html][this]] guide. (See also [[https://blog.onionstudio.com.tw/emacs-for-javascript/][here]])

**** =js2-mode=
     From [[http://elpa.gnu.org/packages/js2-mode.html][here]].\\
     This is THE JavaScript major mode.

     Let's install it and use it for *.js files.
     #+BEGIN_SRC emacs-lisp
       (use-package js2-mode
         :mode ("\\.js\\'")
         :init
         (setq js-indent-level 2))
     #+END_SRC
**** =xref2-js=
     From [[https://github.com/NicolasPetton/xref-js2][here]].\\
     This package provide a =xref= backend to easily jump to definitions in js
     files. It uses =ag=

     #+BEGIN_SRC emacs-lisp
       ;; (use-package xref-js2
       ;;   :bind (
       ;;          ;; Unbind M-. from js-mode-map, conflict with xref
       ;;          :map js-mode-map
       ;;          ("M-." . nil))
       ;;   ;; Add xref-js2 backend to xref-backends in js2-mode
       ;;   :hook (js2-mode . (lambda ()
       ;;                       (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t))))
     #+END_SRC
**** =js2-refactor=
     This package (see [[https://github.com/magnars/js2-refactor.el][here]]) adds cool refactoring features !

     Map it to =C-c C-r= and enabled it automatically for js files.
     #+BEGIN_SRC emacs-lisp
       (use-package js2-refactor
         :hook (js2-mode . js2-refactor-mode)
         :config
         (js2r-add-keybindings-with-prefix "C-c C-r"))
     #+END_SRC
**** =company-tern=
     See [[https://github.com/proofit404/company-tern][here]].\\
     A =company= backend based on [[https://github.com/ternjs/tern][tern]], to have a nice auto-completion for
     JavaScript.

     It requires to have =tern= installed on the system. Let's do it globally by
     running the following command :
     #+BEGIN_SRC sh :tangle no
       npm install -g tern
     #+END_SRC
     TODO: I need to find a way to make my =NVM= lazy-loading works with
     Emacs.\\
     For now, I disabled it and source the =nvm.sh= script by default.

     You need to have a =~/.tern-config= and/or a =.tern-projectile= file at the
     root of your project. See [[http://ternjs.net/doc/manual.html][here]] for the documentation.

     =tern= doesn't do live-reload of =.tern-project= files, you need to restart
     the server to do so.\\
     Since there's no built-in function in =tern.el= to kill or restart the
     server gracefully, I wrote my own function (inspired by [[https://truongtx.me/2014/04/20/emacs-javascript-completion-and-refactoring][this]]) to kill all
     the =tern= server processes.\\
     That way, =company-tern= will launch a new server with the up-to-date
     configuration the next time I call company.

     That's kind of hackish, but it's the simplest solution I found, since I'm
     very bad at elisp.
     #+BEGIN_SRC emacs-lisp
       ;; (defun lrn/kill-tern-servers ()
       ;;   "Kill all the Tern server processes"
       ;;   (interactive)
       ;;   (dolist (process (process-list))
       ;;     (let ((pname (process-name process)))
       ;;       (if (string-match "Tern" pname)
       ;;           (kill-process pname))))
       ;;   (message "All the Tern server processes were killed."))
     #+END_SRC

     #+BEGIN_SRC emacs-lisp
       ;; (use-package company-tern
       ;;   :after company
       ;;   :hook (js2-mode . (lambda ()
       ;;                       (add-to-list 'company-backends 'company-tern)
       ;;                       (tern-mode)))
       ;;   :bind (:map tern-mode-keymap
       ;;          ("M-." . nil)
       ;;          ("M-," . nil)
       ;;          :map js2-mode-map
       ;;          ("C-c k" . lrn/kill-tern-servers)))
     #+END_SRC

**** =tide=
     =tide= (see [[https://github.com/ananthakumaran/tide][here]]) is another JavaScript/TypeScript IDE, built on
     =tsserver=.\\
     It seems to offer a lot a cool features, including completion, doc,
     refactoring, linting, jump to definition and stuff.

     Let's try it to see if it can supplant =tern=, =xref2-js=, =js2-refactor=...
     #+BEGIN_SRC emacs-lisp
       (defun lrn/tide-setup-hook ()
         (company-mode t)
         (flycheck-mode t)
         (tide-setup)
         (tide-hl-identifier-mode)
         (add-hook 'before-save-hook 'tide-format-before-save t 'make-it-local))

       (use-package tide
         :hook ((js2-mode . lrn/tide-setup-hook)
                (typescript-mode . lrn/tide-setup-hook)))
     #+END_SRC

     =tide=, needs you to have at least on =jsconfig.json= or =tsconfig.json= at
     the root of your project (since it works with =tsserver=, just like
     VSCode). See [[https://code.visualstudio.com/docs/languages/jsconfig][here]] for the syntax.

     Conclusion: It does a wonderful job, giving me all the features of the 2
     up-mentioned packages in one.\\
     The refactoring is very light compared to =js2-refactor=, so I'll keep it.\\
     However, it doesn't come with a keymap. I need to map a lot of stuff myself.

     It also seems that =tide= doesn't work for a javascript buffer not
     associated to a file... Need to find more info about that.
**** Stuff to try !
     [[http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html#install_emacs_packages][ESLint]] - Tide is suppose to do linting, but I don't know if it's JSHint
     like js-mode... EDIT: eslint is shipped with =js2-mode=, however, I'll read
     the blog post.
     [[https://github.com/NicolasPetton/Indium][Indium]] or [[https://github.com/skeeto/skewer-mode][Skewer]] - Both are environment to do live dev. Apparently Indium
     can do more (evaluating JS, scratch buffer, REPL, debugging). I never
     really used this kind of features, but it could be fun to try.
*** Go
    Check [[http://tleyden.github.io/blog/2014/05/22/configure-emacs-as-a-go-editor-from-scratch/][this]], [[https://johnsogg.github.io/emacs-golang][this]], [[https://www.reddit.com/r/emacs/comments/5t6rnt/recommended_configpackages_for_golang/][this]], [[http://yousefourabi.com/blog/2014/05/emacs-for-go/][this]] and [[http://dominik.honnef.co/posts/2013/03/writing_go_in_emacs/][that]].

    Almost all of the following packages requires the golang tools.
    They can all be installed at once by running:
    #+BEGIN_SRC sh :tangle no
      go get -u golang.org/x/tools/cmd/...
    #+END_SRC

    You need to have =gopls= installed and available on your =PATH= for =LSP= to
    work with =golang=
    #+BEGIN_SRC sh :tangle no
      GO111MODULE=on go get golang.org/x/tools/gopls@latest
    #+END_SRC

**** =go-mode=
     From [[https://github.com/dominikh/go-mode.el][here]].

     A major-mode for Golang ! Provides a lot of features, such as =gofmt=,
     =godef= or =godoc= integration.

     #+BEGIN_SRC emacs-lisp
       (use-package go-mode
         :mode ("\\.go\\'")
         :hook ((go-mode . (lambda () (add-hook 'before-save-hook 'gofmt-before-save nil 'local))))
         :bind
         (:map go-mode-map
               ;; ("C-c C-r" . go-remove-unused-imports)
               ;; ("C-c C-k" . godoc)
               ;; ("C-c k" . godoc-at-point)
               )
         :config
         (progn
           ))
     #+END_SRC

**** =goimports=
     From [[https://godoc.org/golang.org/x/tools/cmd/goimports][here]].\\
     This golang command manages imports for you !

     You need to install the =goimports= binary first.
     #+BEGIN_SRC sh :tangle no
       go get -u golang.org/x/tools/cmd/goimports
     #+END_SRC

     Then set it as =gofmt-command=
     #+BEGIN_SRC emacs-lisp
       (setq gofmt-command "goimports")
     #+END_SRC

*** PHP
    TODO: Check [[https://www.philnewton.net/guides/emacs-as-a-php-editor/][this]], [[http://irreal.org/blog/?p=5499][this]], [[http://www.blogbyben.com/2016/08/emacs-php-modern-and-far-more-complete.html][this]], [[https://www.drupal.org/docs/develop/development-tools/emacs][this]] and [[https://github.com/emacs-php/php-suite][that]].

    A major mode for =php= files.
    #+BEGIN_SRC emacs-lisp
      (use-package php-mode
        :mode ("\\.php\\'"))
    #+END_SRC
*** Lua
**** =lua-mode=
     From [[https://github.com/immerrr/lua-mode][here]]. See [[http://immerrr.github.io/lua-mode/][here]].

     A major mode to edit Lua files.

     #+BEGIN_SRC emacs-lisp
       (use-package lua-mode
         :mode ("\\.lua\\'"))
     #+END_SRC
*** Arduino
**** =arduino-mode=
     From [[https://github.com/bookest/arduino-mode][here]].

     #+BEGIN_SRC emacs-lisp
       (use-package arduino-mode
         :mode ("\\.ino\\'"))
     #+END_SRC
*** Fish
    From [[https://github.com/wwwjfy/emacs-fish][here]].
    A major mode to support =Fish= script, since they use a different syntax than =Bash=
    #+BEGIN_SRC emacs-lisp
      (use-package fish-mode
        :mode ("\\.fish\\'"))
    #+END_SRC
*** Rust
    From [[https://github.com/rust-lang/rust-mode][here]].
    See [[https://www.reddit.com/r/rust/comments/a3da5g/my_entire_emacs_config_for_rust_in_fewer_than_20/][here]], [[https://www.mortens.dev/blog/emacs-and-the-language-server-protocol/][here]].

    A major mode for =Rust= files.
    #+BEGIN_SRC emacs-lisp
      (use-package rust-mode
        :mode ("\\.rs\\.'"))
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (use-package cargo
        :hook (rust-mode . cargo-minor-mode))
    #+END_SRC

    You need to have =rls= (the Rust language server) installed and available in
    your path for =lsp= to be happy.
    #+BEGIN_SRC sh :tangle no
      rustup component add rls rust-analysis rust-src
    #+END_SRC
** Shell
   I use my terminal A LOT. So if I can use it directly in Emacs and so some
   cool tricks...

*** =multi-term=
    From [[https://www.emacswiki.org/emacs/MultiTerm][here]].\\
    I'm not sure why I chose =multi-term=, but it looks like a popular option !
    Thanks @[[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org#terminal][HRS]]

    Let's bind it to =t= on my custom map
    #+BEGIN_SRC emacs-lisp
      (use-package multi-term
        :bind (
               :map lrn/custom-map
               ("t" . multi-term)))
    #+END_SRC

*** =shell-command=
    By default, =shell-command= is bound on =M-!=. It may be fine for the rest
    of the world, but for me, using Chunkwm on OSX, I use this binding to change
    workspace...

    Let's rebind =shell-command= on =T= in my custom map.
    #+BEGIN_SRC emacs-lisp
      (bind-key "T" 'shell-command lrn/custom-map)
    #+END_SRC
** Docker
   See [[http://manuel-uberti.github.io/emacs/2017/10/19/docker/][here]].\\
   Praise the blue whale \o/

   TODO: Check [[https://github.com/Silex/docker.el][this]] package.
*** =dockerfile-mode=
    See [[https://github.com/spotify/dockerfile-mode][here]].\\
    This package adds syntax highlighting for =Dockerfile=s and =docker build= feature to Emacs.
    What's not to love ?

    #+BEGIN_SRC emacs-lisp
      (use-package dockerfile-mode
        :mode ("Dockerfile\\'"))
    #+END_SRC

*** =docker-compose-mode=
    See [[https://github.com/meqif/docker-compose-mode][here]].\\
    This packages adds completion for =docker-compose.yml= files.
    Simple, basique !

    #+BEGIN_SRC emacs-lisp
      (use-package docker-compose-mode)
    #+END_SRC
** LSP
   From [[https://github.com/emacs-lsp/lsp-mode][here]].
   See [[https://cestlaz.github.io/post/using-emacs-58-lsp-mode/][here]].

   #+BEGIN_SRC emacs-lisp
     (use-package lsp-mode
       :hook (prog-mode . lsp)
       :bind (
              :map lsp-mode-map
              ("C-c f" . lsp-format-buffer)
              ("C-c r" . lsp-rename)
              )
       :config
       (progn
         (setq
          lsp-auto-guess-root t
          ;; Arguments for clangd (C/C++)
          lsp-clients-clangd-args '("-j=4" "-background-index" "-log=error")
          )))
   #+END_SRC

   From [[https://github.com/emacs-lsp/lsp-ui][here]].
   #+BEGIN_SRC emacs-lisp
     (defun lrn/toggle-lsp-ui-doc ()
       (interactive)
       (if lsp-ui-doc-mode
           (progn
             (lsp-ui-doc-mode -1)
             (lsp-ui-doc--hide-frame))
         (lsp-ui-doc-mode 1)))

     (use-package lsp-ui
       :bind
       (
        :map lsp-mode-map
        ("M-." . lsp-ui-peek-find-definitions)
        ("M-?" . lsp-ui-peek-find-references)
        ("C-c i" . lsp-ui-peek-find-implementation)
        ("C-c u m"   . lsp-ui-imenu)
        ("C-c u s"   . lsp-ui-sideline-mode)
        ("C-c u d"   . lrn/toggle-lsp-ui-doc)
        ))
   #+END_SRC

   From [[https://github.com/tigersoldier/company-lsp][here]].
   #+BEGIN_SRC emacs-lisp
     (use-package company-lsp
       :config
       (progn
         (setq
          company-lsp-cache-candidates t ;; auto, t(always using a cache), or nil
          )))

   #+END_SRC

   From [[https://github.com/emacs-lsp/lsp-treemacs][here]].
   #+BEGIN_SRC emacs-lisp
     (use-package lsp-treemacs
       :bind (
              :map lsp-mode-map
              ("C-c t" . lsp-treemacs-errors-list)))
   #+END_SRC

* Miscellaneous
** =speed-type=
   From [[https://github.com/hagleitn/speed-type][here]].

   Considering the time I spent on [[https://10fastfingers.com/][10FastFingers]], it's obvious that I need a
   similar mode in Emacs :D And there's one <3

   Run it with =M-x speed-type-text=
   #+BEGIN_SRC emacs-lisp
     (use-package speed-type)
   #+END_SRC
** =sx=
   From [[https://github.com/vermiculus/sx.el][here]].

   What ? A mode to browse Stack Exchange websites from within Emacs ? REALLY ?

   TODO: I want to switch to =evil-insert-state= when I enter
   =sx-question-list-mode=,  but the hook doesn't seems to work =/
   #+BEGIN_SRC emacs-lisp
     (use-package sx
       :init
       (setq sx-default-site 'stackoverflow)
       ;; This is my workaround to replicate the sx-default-site feature using Ivy
       (add-to-list 'ivy-initial-inputs-alist '(sx-search . "^stackoverflow"))
       (add-to-list 'ivy-initial-inputs-alist '(sx-tab-all-questions . "^stackoverflow"))
       :config
       (bind-keys :map lrn/custom-map
                  :prefix "s"
                  :prefix-map lrn/sx-map
                  :prefix-docstring "Global keymap for SX."
                  ("q" . sx-tab-all-questions)
                  ("i" . sx-inbox)
                  ("o" . sx-open-link)
                  ("u" . sx-tab-unanswered-my-tags)
                  ("a" . sx-ask)
                  ("s" . sx-search)))
   #+END_SRC
